diff -ru vlc-2.1.2.orig/modules/gui/qt4/actions_manager.cpp vlc-2.1.2/modules/gui/qt4/actions_manager.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/actions_manager.cpp	2013-12-03 11:12:34.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/actions_manager.cpp	2014-01-17 16:55:14.874992774 +0200
@@ -35,6 +35,9 @@
 #include "main_interface.hpp" /* Show playlist */
 #include "components/controller.hpp" /* Toggle FSC controller width */
 
+#include <QDesktopServices>
+#include <QUrl>
+
 ActionsManager * ActionsManager::instance = NULL;
 
 ActionsManager::ActionsManager( intf_thread_t * _p_i, QObject *_parent )
@@ -97,6 +100,41 @@
             if( p_intf->p_sys->p_mi )
                 p_intf->p_sys->p_mi->getFullscreenControllerWidget()->toggleFullwidth();
             break;
+        case SAVE_P2P_ACTION : {
+            input_thread_t *p_input = THEMIM->getInput();
+            if( p_input ) {
+                input_item_t *p_item = input_GetItem( p_input );
+                if( p_item )
+                    THEDP->p2p_SaveDialog( p_item );
+            }
+            else {
+                playlist_item_t *p_last_playing_item = playlist_LastPlayingItem(THEPL);
+                if( p_last_playing_item && p_last_playing_item->p_input ) {
+                    THEDP->p2p_SaveDialog( p_last_playing_item->p_input );
+                }
+            }
+            break;
+        }
+        case VISIT_AD_ACTION: {
+            QString url = THEMIM->getIM()->getVisitUrl();
+            if(!url.isEmpty()) {
+                bool fs = var_GetBool( THEPL, "fullscreen" );
+                if(fs)
+                    fullscreen();
+                QDesktopServices::openUrl(QUrl(url));
+            }
+            break;
+        }
+        case DISABLE_AD_ACTION: {
+            QString url = THEMIM->getIM()->getDisableUrl();
+            if(!url.isEmpty()) {
+                bool fs = var_GetBool( THEPL, "fullscreen" );
+                if(fs)
+                    fullscreen();
+                QDesktopServices::openUrl(QUrl(url));
+            }
+            break;
+        }
         default:
             msg_Dbg( p_intf, "Action: %i", id_action );
             break;
diff -ru vlc-2.1.2.orig/modules/gui/qt4/actions_manager.hpp vlc-2.1.2/modules/gui/qt4/actions_manager.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/actions_manager.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/actions_manager.hpp	2014-01-21 15:44:09.332755797 +0200
@@ -56,6 +56,9 @@
     LOOP_ACTION,
     INFO_ACTION,
     OPEN_SUB_ACTION,
+    SAVE_P2P_ACTION,
+    VISIT_AD_ACTION,
+    DISABLE_AD_ACTION,
 } actionType_e;
 
 class ActionsManager : public QObject
@@ -90,8 +93,9 @@
     void record();
     void skipForward();
     void skipBackward();
-protected slots:
     void fullscreen();
+
+protected slots:
     void snapshot();
     void playlist();
     void frame();
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/complete_preferences.cpp vlc-2.1.2/modules/gui/qt4/components/complete_preferences.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/complete_preferences.cpp	2013-09-12 18:18:33.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/complete_preferences.cpp	2014-01-17 16:59:59.842993015 +0200
@@ -99,6 +99,7 @@
         /* This is a category */
         case CONFIG_CATEGORY:
             if( p_item->value.i == -1 ) break;
+            if( p_item->value.i == CAT_WEB_PLUGIN ) break;
 
             /* PrefsItemData Init */
             data = new PrefsItemData();
@@ -139,6 +140,7 @@
         /* This is a subcategory */
         case CONFIG_SUBCATEGORY:
             if( p_item->value.i == -1 ) break;
+            if( p_item->value.i == SUBCAT_WEB_PLUGIN_INTERFACE ) break;
 
             /* Special cases: move the main subcategories to the parent cat*/
             if( data &&
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/controller.cpp vlc-2.1.2/modules/gui/qt4/components/controller.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/controller.cpp	2013-12-05 18:39:06.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/components/controller.cpp	2014-03-04 18:15:23.453954948 +0200
@@ -66,6 +66,7 @@
 {
     p_intf = _p_i;
     advControls = NULL;
+    advertControls = NULL;
     buttonGroupLayout = NULL;
 
     /* Main action provider */
@@ -81,6 +82,7 @@
 void AbstractController::setStatus( int status )
 {
     bool b_hasInput = THEMIM->getIM()->hasInput();
+    emit inputStopped( status != PLAYING_S && status != PAUSE_S );
     /* Activate the interface buttons according to the presence of the input */
     emit inputExists( b_hasInput );
 
@@ -188,6 +190,12 @@
 
             }
             buttonGroupLayout->addWidget( widg );
+            if(i_type == SKIP_AD_BUTTON)
+                buttonGroupLayout->setAlignment(widg, Qt::AlignLeft);
+            else if(i_type == DISABLE_AD_BUTTON)
+                buttonGroupLayout->setAlignment(widg, Qt::AlignRight);
+            else if(i_type == VISIT_AD_SITE_BUTTON)
+                buttonGroupLayout->setAlignment(widg, Qt::AlignHCenter);
         }
         else /* Special widgets */
         {
@@ -224,6 +232,19 @@
     BUTTON_SET_BAR( name ## Button );                   \
     widget = name ## Button;
 
+#define NORMAL_BUTTON_WITH_TEXT( name )                 \
+    QToolButton * name ## Button = new QToolButton;     \
+    name ## Button->setFixedHeight(26); \
+    static QSizePolicy sizePolicy( QSizePolicy::Fixed, QSizePolicy::Fixed ); \
+    sizePolicy.setHorizontalStretch( 0 ); \
+    sizePolicy.setVerticalStretch( 0 ); \
+    name ## Button->setSizePolicy( sizePolicy ); \
+    name ## Button->setFocusPolicy( Qt::NoFocus ); \
+    CONNECT_MAP_SET( name ## Button, name ## _ACTION ); \
+    name ## Button->setToolTip( qtr( tooltipL[button] ) );    \
+    name ## Button->setText( qtr( nameL[button] ) );    \
+    widget = name ## Button;
+
 QWidget *AbstractController::createWidget( buttonType_e button, int options )
 {
     bool b_flat  = options & WIDGET_FLAT;
@@ -354,6 +375,14 @@
         /* Update the position when the IM has changed */
         CONNECT( THEMIM->getIM(), positionUpdated( float, int64_t, int ),
                 slider, setPosition( float, int64_t, int ) );
+
+        CONNECT( THEMIM->getIM(), updateSliderLiveStreamPos( int, int, int, int, int, int, int ), 
+                slider, setLivePosition( int, int, int, int, int, int, int ) );
+        CONNECT( THEMIM->getIM(), disableSeekOnSliderDrag( bool ), slider, disableDragSeek( bool ) );
+        CONNECT( THEMIM->getIM(), enableSliderLiveStreamMode( bool ), slider, isLiveStreamMode( bool ) );
+        CONNECT( THEMIM->getIM(), liveSeekOccured(), slider, setIgnoreLiveStreamChanging() );
+        CONNECT( slider, liveSeek( int ), THEMIM->getIM(), liveSeekEvent( int ) );
+
         /* And update the IM, when the position has changed */
         CONNECT( slider, sliderDragged( float ),
                  THEMIM->getIM(), sliderUpdate( float ) );
@@ -403,6 +432,25 @@
             widget = advControls;
         }
         break;
+    case ADVERT_CONTROLLER:
+        {
+            advertControls = new AdvertisementControllerWidget( p_intf, this );
+            widget = advertControls;
+        }
+        break;
+    case MAIN_PANEL_CONTROLLER:
+        {
+            mainControls = new MainControllerWidget( p_intf, this );
+            widget = mainControls;
+        }
+        break;
+    
+    case FS_PANEL_CONTROLLER:
+        {
+            mainFSControls = new MainFSControllerWidget( p_intf, this );
+            widget = mainFSControls;
+        }
+        break;
     case REVERSE_BUTTON:{
         QToolButton *reverseButton = new QToolButton;
         setupButton( reverseButton );
@@ -481,6 +529,105 @@
     case TIME_LABEL_REMAINING:
         widget = new TimeLabel( p_intf, TimeLabel::Remaining );
         break;
+    case SAVE_P2P_BUTTON : {
+        SaveButton *saveButton = new SaveButton;
+		setupButton( saveButton );
+		BUTTON_SET_BAR(  saveButton );
+		CONNECT_MAP_SET( saveButton, SAVE_P2P_ACTION );
+		CONNECT( THEMIM->getIM(), enableSaveButton( bool ), saveButton, updateButton( bool ) );
+		widget = saveButton;
+        }
+        break;
+    case LIVE_P2P_BUTTON: {
+        LiveButton *liveButton = new LiveButton;
+        static QSizePolicy sizePolicy( QSizePolicy::Fixed, QSizePolicy::Fixed );
+        sizePolicy.setHorizontalStretch( 0 );
+        sizePolicy.setVerticalStretch( 0 );
+        liveButton->setSizePolicy( sizePolicy );
+        liveButton->setFocusPolicy( Qt::NoFocus );
+        liveButton->setToolTip( qtr( tooltipL[button] ) );
+        liveButton->setIcon( QIcon( iconL[button] ) );
+        liveButton->setText( qtr("Live") );
+        CONNECT( THEMIM->getIM(), enableLiveStreamButton( bool ), liveButton, updateButton( bool ) );
+        CONNECT( THEMIM->getIM(), updateLiveStreamButton( bool ), liveButton, updateState( bool ) );
+        CONNECT( this, inputStopped( bool ), liveButton, updateStopped( bool ) );
+        CONNECT( liveButton, clickSignal( int ),  THEMIM->getIM(), liveSeekEvent( int ) );
+        widget = liveButton;
+		}
+		break;
+    case QUALITY_P2P_BUTTON: {
+        QualityButton *qualityButton = new QualityButton;
+        qualityButton->setFixedHeight(26);
+        static QSizePolicy sizePolicy( QSizePolicy::Fixed, QSizePolicy::Fixed );
+        sizePolicy.setHorizontalStretch( 0 );
+        sizePolicy.setVerticalStretch( 0 );
+        qualityButton->setSizePolicy( sizePolicy );
+        qualityButton->setFocusPolicy( Qt::NoFocus );
+        qualityButton->setToolTip( qtr( tooltipL[button] ) );
+        qualityButton->setText("");
+        CONNECT( THEMIM->getIM(), enableQualitiesButton(QStringList, int), qualityButton, updateButton(QStringList, int) );
+        CONNECT( qualityButton, clickSignal( int ),  THEMIM->getIM(), changeQuality( int ) );
+        widget = qualityButton;
+		}
+		break;
+
+    case SKIP_AD_BUTTON: {
+        SkipAdButton *skipButton = new SkipAdButton;
+        skipButton->setFixedHeight(26);
+        static QSizePolicy sizePolicy( QSizePolicy::Fixed, QSizePolicy::Fixed );
+        sizePolicy.setHorizontalStretch( 0 );
+        sizePolicy.setVerticalStretch( 0 );
+        skipButton->setSizePolicy( sizePolicy );
+        skipButton->setFocusPolicy( Qt::NoFocus );
+        
+        CONNECT( THEMIM->getIM(), setWaitForAd(int),  skipButton, waitLabelValue(int) );
+        CONNECT( skipButton, clickSignal(), THEMIM->getIM(), skipAd() );
+        
+        skipButton->setToolTip( qtr( tooltipL[button] ) );
+        skipButton->setText( qtr( nameL[button] ) );
+        
+        widget = skipButton;
+        }
+        break;
+
+    case VISIT_AD_SITE_BUTTON: {
+        VisitAdButton *visitButton = new VisitAdButton;
+        visitButton->setFixedHeight(26);
+        static QSizePolicy sizePolicy( QSizePolicy::Fixed, QSizePolicy::Fixed );
+        sizePolicy.setHorizontalStretch( 0 );
+        sizePolicy.setVerticalStretch( 0 );
+        visitButton->setSizePolicy( sizePolicy );
+        visitButton->setFocusPolicy( Qt::NoFocus );
+        
+        CONNECT( THEMIM->getIM(), setVisitAdButtonText(QString), visitButton, updateText(QString) );
+        CONNECT( THEMIM->getIM(), setVisitAdButtonEnable(bool),  visitButton, enableChanged(bool) );
+        CONNECT_MAP_SET( visitButton, VISIT_AD_ACTION );
+        
+        visitButton->setToolTip( qtr( tooltipL[button] ) );
+        visitButton->setText( qtr( nameL[button] ) );
+        
+        widget = visitButton;
+        }
+        break;
+
+    case DISABLE_AD_BUTTON: {
+        DisableAdButton *disButton = new DisableAdButton;
+        disButton->setFixedHeight(26);
+        static QSizePolicy sizePolicy( QSizePolicy::Fixed, QSizePolicy::Fixed );
+        sizePolicy.setHorizontalStretch( 0 );
+        sizePolicy.setVerticalStretch( 0 );
+        disButton->setSizePolicy( sizePolicy );
+        disButton->setFocusPolicy( Qt::NoFocus );
+        
+        CONNECT( THEMIM->getIM(), setDisableAdButtonEnable(bool),  disButton, enableChanged(bool) );
+        CONNECT_MAP_SET( disButton, DISABLE_AD_ACTION );
+        
+        disButton->setToolTip( qtr( tooltipL[button] ) );
+        disButton->setText( qtr( nameL[button] ) );
+        
+        widget = disButton;
+        }
+        break;
     default:
         msg_Warn( p_intf, "This should not happen %i", button );
         break;
@@ -647,31 +794,38 @@
     RTL_UNAFFECTED_WIDGET
     /* advanced Controls handling */
     b_advancedVisible = b_advControls;
+    b_advertisementVisible = false;
 #ifdef DEBUG_LAYOUT
     setStyleSheet( "background: red ");
 #endif
     setAttribute( Qt::WA_MacBrushedMetal);
-    controlLayout = new QVBoxLayout( this );
+    QVBoxLayout *controlLayout = new QVBoxLayout( this );
     controlLayout->setContentsMargins( 3, 1, 0, 1 );
     controlLayout->setSpacing( 0 );
+
+    QHBoxLayout *controlLayout0 = new QHBoxLayout;
+    controlLayout0->setSpacing( 0 ); controlLayout0->setMargin( 0 );
+    QString line0 = getSettings()->value( "MainWindow/MainToolbar0", ADVERT_PANEL_DEFAULT )
+                                        .toString();
+    parseAndCreate( line0, controlLayout0 );
+
     QHBoxLayout *controlLayout1 = new QHBoxLayout;
     controlLayout1->setSpacing( 0 ); controlLayout1->setMargin( 0 );
 
     QString line1 = getSettings()->value( "MainWindow/MainToolbar1", MAIN_TB1_DEFAULT )
                                         .toString();
     parseAndCreate( line1, controlLayout1 );
-
     QHBoxLayout *controlLayout2 = new QHBoxLayout;
     controlLayout2->setSpacing( 0 ); controlLayout2->setMargin( 0 );
-    QString line2 = getSettings()->value( "MainWindow/MainToolbar2", MAIN_TB2_DEFAULT )
-                                        .toString();
+    QString line2 = getSettings()->value( "MainWindow/MainToolbar3", MAIN_PANEL_DEFAULT ).toString();
     parseAndCreate( line2, controlLayout2 );
-
-    grip = new QSizeGrip( this );
-    controlLayout2->addWidget( grip, 0, Qt::AlignBottom|Qt::AlignRight );
-
+    
     if( !b_advancedVisible && advControls ) advControls->hide();
 
+    if( !b_advertisementVisible && advertControls ) advertControls->hide();
+    
+    controlLayout->addLayout( controlLayout0 );
+    controlLayout->setAlignment( controlLayout1, Qt::AlignHCenter );
     controlLayout->addLayout( controlLayout1 );
     controlLayout->addLayout( controlLayout2 );
 }
@@ -685,6 +839,30 @@
     emit advancedControlsToggled( b_advancedVisible );
 }
 
+void ControlsWidget::toogleAdvertisementPanel(bool isAd)
+{
+    if( !advertControls ) return;
+    if(b_advertisementVisible != isAd) {
+        advertControls->setVisible( isAd );
+        mainControls->setVisible( !isAd );
+        
+        if( b_advancedVisible )
+            advControls->setVisible( !isAd );
+        
+        b_advertisementVisible = isAd;
+    }
+}
+
+void ControlsWidget::hideMainControls()
+{
+    mainControls->setVisible(false);
+}
+
+void ControlsWidget::showMainControls()
+{
+    mainControls->setVisible(true);
+}
+
 AdvControlsWidget::AdvControlsWidget( intf_thread_t *_p_i, QWidget *_parent ) :
                                      AbstractController( _p_i, _parent )
 {
@@ -702,6 +880,45 @@
     parseAndCreate( line, controlLayout );
 }
 
+AdvertisementControllerWidget::AdvertisementControllerWidget( intf_thread_t *_p_i, QWidget *_parent ) :
+                                     AbstractController( _p_i, _parent )
+{
+    RTL_UNAFFECTED_WIDGET
+    controlLayout = new QHBoxLayout( this );
+    controlLayout->setMargin( 0 );
+    controlLayout->setSpacing( 0 );
+    
+    QString line = getSettings()->value( "MainWindow/AdvertToolbar", ADVERT_TB_DEFAULT ).toString();
+    parseAndCreate( line, controlLayout );
+}
+
+MainControllerWidget::MainControllerWidget( intf_thread_t *_p_i, QWidget *_parent ) :
+                                     AbstractController( _p_i, _parent )
+{
+    RTL_UNAFFECTED_WIDGET
+    controlLayout = new QHBoxLayout( this );
+    controlLayout->setMargin( 0 );
+    controlLayout->setSpacing( 0 );
+    
+    QString line = getSettings()->value( "MainWindow/MainToolbar2", MAIN_TB2_DEFAULT ).toString();
+    parseAndCreate( line, controlLayout );
+
+    grip = new QSizeGrip( this );
+    controlLayout->addWidget( grip, 0, Qt::AlignBottom|Qt::AlignRight );
+}
+
+MainFSControllerWidget::MainFSControllerWidget( intf_thread_t *_p_i, QWidget *_parent ) :
+                                     AbstractController( _p_i, _parent )
+{
+    RTL_UNAFFECTED_WIDGET
+    controlLayout = new QHBoxLayout( this );
+    controlLayout->setMargin( 0 );
+    controlLayout->setSpacing( 0 );
+    
+    QString line = getSettings()->value( "MainWindow/FSCtoolbar", FSC_TB_DEFAULT ).toString();
+    parseAndCreate( line, controlLayout );
+}
+
 InputControlsWidget::InputControlsWidget( intf_thread_t *_p_i, QWidget *_parent ) :
                                      AbstractController( _p_i, _parent )
 {
@@ -735,6 +952,11 @@
     b_fullscreen        = false;
     i_hide_timeout      = 1;
     i_screennumber      = -1;
+    b_advertisementVisible = false;
+    
+    b_can_hide = true;
+    cachedPos = QPoint(-1,-1);
+    i_context_y = -1;
 
     vout.clear();
 
@@ -753,11 +975,25 @@
     InputControlsWidget *inputC = new InputControlsWidget( p_intf, this );
     controlLayout2->addWidget( inputC );
 
+    QHBoxLayout *controlLayout0 = new QHBoxLayout;
+    controlLayout0->setSpacing( 0 ); controlLayout0->setMargin( 0 );
+
+    QString line0 = getSettings()->value( "MainWindow/FSCAdvertToolbar", ADVERT_PANEL_DEFAULT )
+                                        .toString();
+    parseAndCreate( line0, controlLayout0 );
+
+    //controlLayout = new QHBoxLayout;
+    //QString line = getSettings()->value( "MainWindow/FSCtoolbar", FSC_TB_DEFAULT ).toString();
+    //parseAndCreate( line, controlLayout );
+    
     controlLayout = new QHBoxLayout;
-    QString line = getSettings()->value( "MainWindow/FSCtoolbar", FSC_TB_DEFAULT ).toString();
+    QString line = getSettings()->value( "MainWindow/FSCtoolbar2", FSC_PANEL_DEFAULT ).toString();
     parseAndCreate( line, controlLayout );
+    
+    controlLayout2->addLayout( controlLayout0 );
+    controlLayout2->setAlignment( controlLayout0, Qt::AlignHCenter );
     controlLayout2->addLayout( controlLayout );
-
+    
     /* hiding timer */
     p_hideTimer = new QTimer( this );
     p_hideTimer->setSingleShot( true );
@@ -775,6 +1011,8 @@
     DCONNECT( THEMIM->getIM(), voutListChanged( vout_thread_t **, int ),
               this, setVoutList( vout_thread_t **, int ) );
 
+    if( !b_advertisementVisible && advertControls ) advertControls->hide();
+
     /* First Move */
     previousPosition = getSettings()->value( "FullScreen/pos" ).toPoint();
     screenRes = getSettings()->value( "FullScreen/screen" ).toRect();
@@ -792,6 +1030,16 @@
     vlc_mutex_destroy( &lock );
 }
 
+void FullscreenControllerWidget::toogleAdvertisementPanel(bool isAd)
+{
+    if( !advertControls ) return;
+    if(b_advertisementVisible != isAd) {
+        advertControls->setVisible( isAd );
+        mainFSControls->setVisible( !isAd );
+        b_advertisementVisible = isAd;
+    }
+}
+
 void FullscreenControllerWidget::restoreFSC()
 {
     if( !isWideFSC )
@@ -835,10 +1083,38 @@
 
     /* screen has changed, calculate new position */
     QPoint pos = QPoint( currentRes.x() + (currentRes.width() / 2) - (width() / 2),
-            currentRes.y() + currentRes.height() - height());
+            i_context_y != -1 ? i_context_y - height() : currentRes.y() + currentRes.height() - height());
     move( pos );
 }
 
+void FullscreenControllerWidget::placeFsControls(int y, int height)
+{
+    if(y == -1 && height == -1) {
+        if(cachedPos.x() != -1 && cachedPos.y() != -1) {
+            move(cachedPos);
+            previousPosition = cachedPos;
+            cachedPos = QPoint(-1,-1);
+            i_context_y = -1;
+        }
+    }
+    else if(((this->y() > y && this->y() < y + height) 
+            || (this->y() + this->height() > y && this->y()+ this->height() < y + height)) && b_can_hide) {
+        cachedPos = pos();
+        int y_pos = y - this->height() < 0 ? 0 : y - this->height();
+        move(this->x(), y_pos);
+        previousPosition = QPoint(this->x(), y_pos);
+    }
+    /*if (this->y() + this->height() > y && b_can_hide) {
+        cachedPos = pos();
+        int y_pos = y - this->height() < 0 ? 0 : y - this->height();
+        move(this->x(), y_pos);
+        previousPosition = QPoint(this->x(), y_pos);
+    }*/
+    else {
+        i_context_y = y;
+    }
+}
+
 /**
  * Show fullscreen controller
  */
@@ -879,26 +1155,28 @@
 void FullscreenControllerWidget::slowHideFSC()
 {
 #if HAVE_TRANSPARENCY
-    if( b_slow_hide_begin )
-    {
-        b_slow_hide_begin = false;
+    if(b_can_hide) {
+        if( b_slow_hide_begin )
+        {
+            b_slow_hide_begin = false;
 
-        p_slowHideTimer->stop();
-        /* the last part of time divided to 100 pieces */
-        p_slowHideTimer->start( (int)( i_slow_hide_timeout / 2 / ( windowOpacity() * 100 ) ) );
+            p_slowHideTimer->stop();
+            /* the last part of time divided to 100 pieces */
+            p_slowHideTimer->start( (int)( i_slow_hide_timeout / 2 / ( windowOpacity() * 100 ) ) );
 
-    }
-    else
-    {
-         if ( windowOpacity() > 0.0 )
-         {
-             /* we should use 0.01 because of 100 pieces ^^^
-                but than it cannt be done in time */
-             setWindowOpacity( windowOpacity() - 0.02 );
-         }
+        }
+        else
+        {
+             if ( windowOpacity() > 0.0 )
+             {
+                 /* we should use 0.01 because of 100 pieces ^^^
+                    but than it cannt be done in time */
+                 setWindowOpacity( windowOpacity() - 0.02 );
+             }
 
-         if ( windowOpacity() <= 0.0 )
-             p_slowHideTimer->stop();
+             if ( windowOpacity() <= 0.0 )
+                 p_slowHideTimer->stop();
+        }
     }
 #endif
 }
@@ -970,7 +1248,7 @@
             break;
         /* Hide */
         case IMEvent::FullscreenControlHide:
-            hideFSC();
+            hideFSC(true);
             break;
         default:
             break;
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/controller.hpp vlc-2.1.2/modules/gui/qt4/components/controller.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/controller.hpp	2013-12-05 18:39:06.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/components/controller.hpp	2014-03-04 18:14:46.193954152 +0200
@@ -34,11 +34,15 @@
 #include <QString>
 #include <QSizeGrip>
 
-#define MAIN_TB1_DEFAULT "64;39;64;38;65"
-#define MAIN_TB2_DEFAULT "0-2;64;3;1;4;64;7;9;64;10;20;19;64-4;37;65;35-4"
+#define MAIN_TB1_DEFAULT "96;71;96;70;97"
+#define MAIN_TB2_DEFAULT "0-2;96;3;1;4;96;7;9;96;10;20;19;96;26;27;96-4;69;97;28;96;67-4"
+#define MAIN_PANEL_DEFAULT "78"
 #define ADV_TB_DEFAULT "12;11;13;14"
-#define INPT_TB_DEFAULT "43;33-4;44"
-#define FSC_TB_DEFAULT "0-2;64;3;1;4;64;37;64;38;64;8;65;25;35-4;34"
+#define INPT_TB_DEFAULT "75;65-4;76"
+#define FSC_TB_DEFAULT "0-2;96;3;1;4;96;69;96;70;96;8;96;26;27;97;25;96;28;96;67-4;66"
+#define FSC_PANEL_DEFAULT "79"
+#define ADVERT_PANEL_DEFAULT "77"
+#define ADVERT_TB_DEFAULT "64;29;96;30;96;31;64"
 
 #define I_PLAY_TOOLTIP N_("Play\nIf the playlist is empty, open a medium")
 
@@ -89,9 +93,15 @@
     NEXT_BUTTON,
     OPEN_SUB_BUTTON,
     FULLWIDTH_BUTTON,
+    SAVE_P2P_BUTTON,
+    LIVE_P2P_BUTTON,
+    QUALITY_P2P_BUTTON,
+    SKIP_AD_BUTTON,
+    VISIT_AD_SITE_BUTTON,
+    DISABLE_AD_BUTTON, // 31
     BUTTON_MAX,
 
-    SPLITTER = 0x20,
+    SPLITTER = 0x40,
     INPUT_SLIDER,
     TIME_LABEL,
     VOLUME,
@@ -104,9 +114,12 @@
     SPEED_LABEL,
     TIME_LABEL_ELAPSED,
     TIME_LABEL_REMAINING,
+    ADVERT_CONTROLLER, 
+    MAIN_PANEL_CONTROLLER,
+    FS_PANEL_CONTROLLER,
     SPECIAL_MAX,
 
-    WIDGET_SPACER = 0x40,
+    WIDGET_SPACER = 0x60,
     WIDGET_SPACER_EXTEND,
     WIDGET_MAX,
 } buttonType_e;
@@ -118,7 +131,8 @@
     N_("Record"), N_("A->B Loop"), N_("Frame By Frame"), N_("Trickplay Reverse"),
     N_("Step backward" ), N_("Step forward"), N_("Quit"), N_("Random"),
     N_("Loop / Repeat"), N_("Information"), N_("Previous"), N_("Next"),
-    N_("Open subtitles"), N_("Dock fullscreen controller")
+    N_("Open subtitles"), N_("Dock fullscreen controller"), N_("Save"), N_("Live"), N_("Quality"), 
+    N_("Skip this ad"), N_("Go to advertiser's site"), N_("Disable ads")
 };
 static const char* const tooltipL[BUTTON_MAX] = { I_PLAY_TOOLTIP,
     N_("Stop playback"), N_("Open a medium"),
@@ -132,7 +146,9 @@
     N_("Random"), N_("Change the loop and repeat modes"), N_("Information"),
     N_("Previous media in the playlist"), N_("Next media in the playlist"),
     N_("Open subtitle file"),
-    N_("Dock/undock fullscreen controller to/from bottom of screen")
+    N_("Dock/undock fullscreen controller to/from bottom of screen"),
+    N_("Save File"), N_("Skip ahead to live broadcast"), N_("Change quality"),
+    N_("Skip this ad"), N_("Go to advertiser's site"), N_("Do not display ads anymore")
 };
 static const QString iconL[BUTTON_MAX] ={ ":/toolbar/play_b", ":/toolbar/stop_b",
     ":/toolbar/eject", ":/toolbar/previous_b", ":/toolbar/next_b",
@@ -142,7 +158,8 @@
     ":/toolbar/frame", ":/toolbar/reverse", ":/toolbar/skip_back",
     ":/toolbar/skip_fw", ":/toolbar/clear", ":/buttons/playlist/shuffle_on",
     ":/buttons/playlist/repeat_all", ":/menu/info",
-    ":/toolbar/previous_b", ":/toolbar/next_b", ":/toolbar/eject", ":/toolbar/space"
+    ":/toolbar/previous_b", ":/toolbar/next_b", ":/toolbar/eject", ":/toolbar/space", ":/toolbar/save", ":/toolbar/live", "",
+    "", "", ""
 };
 
 enum
@@ -154,6 +171,9 @@
 };
 
 class AdvControlsWidget;
+class AdvertisementControllerWidget;
+class MainControllerWidget;
+class MainFSControllerWidget;
 class AbstractController : public QFrame
 {
     friend class WidgetListing; /* For ToolBar Edition HACKS */
@@ -166,10 +186,13 @@
     intf_thread_t       *p_intf;
 
     QSignalMapper       *toolbarActionsMapper;
-    QBoxLayout          *controlLayout;
+    QHBoxLayout          *controlLayout;
     /* Change to BoxLayout if both dir are needed */
 
     AdvControlsWidget   *advControls;
+    AdvertisementControllerWidget *advertControls;
+    MainControllerWidget *mainControls;
+    MainFSControllerWidget *mainFSControls;
 
     void parseAndCreate( const QString& config, QBoxLayout *controlLayout );
 
@@ -192,6 +215,8 @@
     void inputPlaying( bool ); /// This might be useful in the IM ?
     void inputIsRecordable( bool ); /// same ?
     void inputIsTrickPlayable( bool ); /// same ?
+    void inputSaveable( bool );
+    void inputStopped( bool );
 };
 
 /* Advanced Button Bar */
@@ -202,6 +227,33 @@
     AdvControlsWidget( intf_thread_t *, QWidget *_parent = 0 );
 };
 
+class AdvertisementControllerWidget : public AbstractController
+{
+    Q_OBJECT
+public:
+    AdvertisementControllerWidget( intf_thread_t *_p_i, QWidget *_parent = 0 );
+};
+
+class MainControllerWidget : public AbstractController
+{
+    Q_OBJECT
+public:
+    MainControllerWidget( intf_thread_t *_p_i, QWidget *_parent = 0 );
+    
+    void setGripVisible( bool b_visible ) { grip->setVisible( b_visible ); }
+    
+private:
+    QSizeGrip *grip;
+    
+};
+
+class MainFSControllerWidget : public AbstractController
+{
+    Q_OBJECT
+public:
+    MainFSControllerWidget( intf_thread_t *_p_i, QWidget *_parent = 0 );
+};
+
 /* Slider Bar */
 class InputControlsWidget : public AbstractController
 {
@@ -219,19 +271,23 @@
     ControlsWidget( intf_thread_t *_p_i, bool b_advControls,
                     QWidget *_parent = 0 );
 
-    void setGripVisible( bool b_visible )
-    { grip->setVisible( b_visible ); }
+    void setGripVisible( bool b_visible ) { mainControls->setGripVisible(b_visible); }
+    //{ grip->setVisible( b_visible ); }
 
 protected:
     friend class MainInterface;
 
     bool b_advancedVisible;
+    bool b_advertisementVisible;
 
 private:
     QSizeGrip *grip;
 
 protected slots:
     void toggleAdvanced();
+    void toogleAdvertisementPanel(bool);
+    void hideMainControls();
+    void showMainControls();
 
 signals:
     void advancedControlsToggled( bool );
@@ -274,6 +330,7 @@
 
 protected:
     friend class MainInterface;
+    bool b_advertisementVisible;
 
     virtual void mouseMoveEvent( QMouseEvent *event );
     virtual void mousePressEvent( QMouseEvent *event );
@@ -284,13 +341,18 @@
 
     virtual void customEvent( QEvent *event );
 
+protected slots:
+    void toogleAdvertisementPanel(bool);
 private slots:
     void showFSC();
     void planHideFSC();
-    void hideFSC() { hide(); }
+    void hideFSC(bool force = false) { if(b_can_hide || force) hide(); }
     void slowHideFSC();
     void restoreFSC();
     void centerFSC( int );
+public slots:
+    void enableHiding(bool val) { b_can_hide = val; if(!val) showFSC(); }
+    void placeFsControls(int y, int height);
 
 private:
     QTimer *p_hideTimer;
@@ -319,6 +381,9 @@
     int i_mouse_last_move_y;
 
     bool isWideFSC;
+    bool b_can_hide;
+    QPoint cachedPos;
+    int i_context_y;
 };
 
 #endif
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/controller_widget.cpp vlc-2.1.2/modules/gui/qt4/components/controller_widget.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/controller_widget.cpp	2013-12-03 11:12:34.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/components/controller_widget.cpp	2014-01-17 17:08:41.230993693 +0200
@@ -38,6 +38,7 @@
 #include <QMenu>
 #include <QWidgetAction>
 #include <QMouseEvent>
+#include <QSignalMapper>
 
 SoundWidget::SoundWidget( QWidget *_parent, intf_thread_t * _p_intf,
                           bool b_shiny, bool b_special )
@@ -120,6 +121,7 @@
     CONNECT( this, valueReallyChanged( int ), this, userUpdateVolume( int ) );
     CONNECT( THEMIM, volumeChanged( float ), this, libUpdateVolume( float ) );
     CONNECT( THEMIM, soundMuteChanged( bool ), this, updateMuteStatus( bool ) );
+    CONNECT( this, clearCachedVolume( void ), THEMIM->getIM(), dropCachedVolume( void ) );
 }
 
 SoundWidget::~SoundWidget()
@@ -154,6 +156,7 @@
     setMuted( false );
     playlist_VolumeSet( THEPL, i_sliderVolume / 100.f );
     refreshLabels();
+    emit clearCachedVolume();
 }
 
 /* libvlc changed value event slot */
@@ -296,3 +299,147 @@
         vlc_object_release( p_vout );
 }
 
+void SaveButton::updateButton( bool b_saveableplaying )
+{
+    setVisible( b_saveableplaying );
+}
+
+LiveButton::LiveButton() : QPushButton(), stopped(true), live(false)
+{ 
+    setVisible(false);
+    CONNECT( this, clicked(), this, buttonClicked() );
+}
+
+void LiveButton::updateButton(bool is_live_stream)
+{
+    setVisible( is_live_stream );
+}
+
+void LiveButton::updateState( bool val ) 
+{
+    if( !stopped ) {
+        live = val;
+        setIcon( live ? QIcon( ":/toolbar/live-live" ) : QIcon( ":/toolbar/live-nolive" ));
+        setToolTip( live ? qtr(N_("You are watching live broadcast")) : qtr(N_("Skip ahead to live broadcast")) );
+    }
+}
+
+void LiveButton::updateStopped( bool val )
+{
+    stopped = val;
+    if( stopped ) {
+        live = false;
+        setIcon(QIcon( ":/toolbar/live" ));
+        setToolTip("");
+    }
+}
+
+void LiveButton::buttonClicked()
+{
+    if( !live ) 
+        emit clickSignal(-1);
+}
+
+QualityButton::QualityButton() : QToolButton(), current_quality(-1)
+{
+    setVisible(false);
+    setPopupMode(QToolButton::InstantPopup);
+    
+    menu = new QMenu( "Qualities" );
+    map = new QSignalMapper(menu);
+    connect(map, SIGNAL(mapped(int)), SLOT(doMenuAction(int)));
+    setMenu(menu);
+}
+
+void QualityButton::createMenu( QStringList q_list, int q_cur_id )
+{
+    qualities = q_list;
+    current_quality = q_cur_id;
+
+    if(menu)
+        menu->clear();
+
+    if( qualities.size() == 0 ) {
+        setVisible(false);
+        return;
+    }
+    
+    for( int i=0; i< qualities.size(); ++i ) {
+        if( current_quality == i ) {
+            setText(qualities.at(i));
+        }
+        else {
+            QAction *action = new QAction(qualities.at(i), menu);
+            connect(action, SIGNAL(triggered()), map, SLOT(map()));
+            map->setMapping(action, i);
+            menu->addAction(action);
+        }
+    }
+    setVisible(true);
+}
+
+void QualityButton::doMenuAction( int q_id )
+{
+    createMenu( qualities, q_id );
+    emit clickSignal( q_id );
+}
+
+void QualityButton::updateButton( QStringList q_list, int q_cur )
+{
+    if( q_list.empty() ) {
+        setVisible(false);
+        return;
+    }
+    if( qualities == q_list && current_quality == q_cur ) {
+        if( !isVisible() )
+            setVisible(true);
+        return;
+    }
+    createMenu( q_list, q_cur );
+}
+
+SkipAdButton::SkipAdButton() : QToolButton(), is_waiting(true)
+{
+    CONNECT( this, clicked(), this, buttonClicked() );
+}
+
+void SkipAdButton::waitLabelValue(int wait) {
+    if(wait == -1) {
+        setText( QString(qtr("Skip this ad")) );
+        is_waiting = false;
+    }
+    else {
+        setText( QString::number(wait) + " " + QString(qtr("Advertising")) );
+        is_waiting = true;
+    }
+}
+
+void SkipAdButton::buttonClicked()
+{
+    if(!is_waiting)
+        emit clickSignal();
+}
+
+VisitAdButton::VisitAdButton() : QToolButton()
+{
+}
+
+void VisitAdButton::enableChanged(bool val)
+{
+    setVisible(val);
+}
+
+void VisitAdButton::updateText(QString val)
+{
+    setText( val == "" ? QString(qtr("Go to advertiser's site")) : val );
+}
+
+DisableAdButton::DisableAdButton() : QToolButton()
+{
+}
+
+void DisableAdButton::enableChanged(bool val)
+{
+    setVisible(val);
+}
+
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/controller_widget.hpp vlc-2.1.2/modules/gui/qt4/components/controller_widget.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/controller_widget.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/controller_widget.hpp	2014-01-17 18:01:49.326996199 +0200
@@ -35,11 +35,13 @@
 #include <QWidget>
 #include <QToolButton>
 #include <QComboBox>
+#include <QPushButton>
 
 class QLabel;
 class QFrame;
 class QSpinBox;
 class QAbstractSlider;
+class QSignalMapper;
 
 /**
  * SPECIAL Widgets that are a bit more than just a ToolButton
@@ -125,6 +127,94 @@
 
 signals:
     void valueReallyChanged( int );
+    void clearCachedVolume();
+};
+
+class SaveButton : public QToolButton
+{
+    Q_OBJECT
+public:
+    SaveButton() : QToolButton() { setVisible(false); }
+private slots:
+    void updateButton( bool );
+};
+
+class LiveButton : public QPushButton
+{
+    Q_OBJECT
+public:
+    LiveButton();
+    
+private:
+    int state;
+    bool stopped, live;
+private slots:
+    void updateButton( bool );
+    void updateState( bool );
+    void updateStopped( bool );
+    void buttonClicked();
+signals:
+    void clickSignal( int );
+};
+
+class QualityButton : public QToolButton
+{
+    Q_OBJECT
+public:
+    QualityButton();
+    
+private:
+    QStringList qualities;
+    int current_quality;
+    QMenu *menu;
+    QSignalMapper *map;
+    
+    void createMenu(QStringList, int);
+
+private slots:
+    void doMenuAction(int);
+    void updateButton(QStringList, int);
+
+signals:
+    void clickSignal( int );
+};
+
+class SkipAdButton : public QToolButton
+{
+    Q_OBJECT
+public:
+    SkipAdButton();
+    
+private:
+    bool is_waiting;
+
+private slots:
+    void buttonClicked();
+    void waitLabelValue(int);
+    
+signals:
+    void clickSignal();
+};
+
+class VisitAdButton : public QToolButton
+{
+    Q_OBJECT
+public:
+    VisitAdButton();
+    
+private slots:
+    void enableChanged(bool);
+    void updateText(QString);
+};
+
+class DisableAdButton : public QToolButton
+{
+    Q_OBJECT
+public:
+    DisableAdButton();
+    
+private slots:
+    void enableChanged(bool);
 };
 
 #endif
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/info_panels.cpp vlc-2.1.2/modules/gui/qt4/components/info_panels.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/info_panels.cpp	2013-09-12 18:18:33.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/info_panels.cpp	2014-01-17 18:01:16.182996111 +0200
@@ -50,6 +50,7 @@
 #include <QLabel>
 #include <QSpinBox>
 #include <QTextEdit>
+#include <QPushButton>
 
 /************************************************************************
  * Single panels
@@ -666,3 +667,99 @@
 void InputStatsPanel::clear()
 {
 }
+
+/*
+ * P2P Info
+ */
+P2PPanel::P2PPanel( QWidget *parent, intf_thread_t *_p_intf ) : QWidget( parent ), p_intf( _p_intf )
+{
+    QGridLayout *p2pLayout = new QGridLayout( this );
+    p2pLayout->setVerticalSpacing( 5 );
+    
+    QFont smallFont = QApplication::font();
+    smallFont.setPointSize( smallFont.pointSize() - 1 );
+    smallFont.setBold( true );
+
+    p_input = NULL;
+    QLabel *label;
+    
+    /* Content ID */
+    label = new QLabel( qtr( "Content ID" ) );
+    label->setFont( smallFont ); 
+    label->setContentsMargins( 3, 2, 0, 0 );
+    p2pLayout->addWidget( label, 0, 0, 1, 9 );
+    cidInput = new QLineEdit;
+    cidInput->setReadOnly(true);
+    p2pLayout->addWidget( cidInput, 1, 0, 1, 9 );
+    
+    cidUpdate = new QPushButton(QIcon(":/update"), "");
+    cidUpdate->setToolTip( qtr("Update content id") );
+    cidUpdate->setVisible( false );
+    BUTTONACT( cidUpdate, updateCid() );
+    p2pLayout->addWidget( cidUpdate, 1, 9, 1, 1 );
+    
+    p2pLayout->setColumnStretch( 1, 20 );
+    p2pLayout->setColumnMinimumWidth ( 1, 80 );
+    p2pLayout->setRowStretch( 2, 10 );
+}
+
+void P2PPanel::clear()
+{
+    cidInput->clear();
+}
+
+void P2PPanel::updateCid()
+{
+    if( !p_input ) {
+        clear();
+        return;
+    }
+    if( input_item_IsP2P( p_input ) ) {
+        /*Content ID*/
+        p2p_uri_id_type_t p2p_type = input_item_GetP2PType(p_input);
+        if( p2p_type == P2P_TYPE_PLAYER ) {
+            char *psz_p2p_uri = input_item_GetP2PUrl( p_input );
+            QString uri = qfu(psz_p2p_uri);
+            free( psz_p2p_uri );
+            uri.replace( "acestream://", "", Qt::CaseInsensitive );
+            cidInput->setText( uri );
+            
+            cidUpdate->setVisible( false );
+        }
+        else {
+            char *psz_infohash = input_item_GetP2PInfohash( p_input );
+            char *psz_checksum = input_item_GetP2PChecksum( p_input );
+            if( psz_infohash && psz_checksum ) {
+                int dev = input_item_GetP2PDeveloper( p_input );
+                int aff = input_item_GetP2PAffiliate( p_input );
+                int zone = input_item_GetP2PZone( p_input );
+                char *psz_cid = p2p_GetCid( THEP2P, psz_infohash, psz_checksum, dev, aff, zone );
+                if( psz_cid ) {
+                    cidInput->setText( qfu( psz_cid ) );
+                    free( psz_cid );
+                }
+                else {
+                    cidInput->setText( "" );
+                    cidUpdate->setVisible( true );
+                }
+                free(psz_infohash);
+                free(psz_checksum);
+            }
+            else
+                cidInput->setText( "" );
+        }
+    }
+    else
+        clear();
+}
+
+void P2PPanel::update( input_item_t *p_item )
+{
+    if( !p_item ) {
+        clear();
+        return;
+    }
+    p_input = p_item;
+    
+    updateCid();
+}
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/info_panels.hpp vlc-2.1.2/modules/gui/qt4/components/info_panels.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/info_panels.hpp	2013-08-08 20:16:57.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/info_panels.hpp	2014-01-17 15:05:13.946987153 +0200
@@ -170,4 +170,23 @@
     void clear();
 };
 
+class P2PPanel: public QWidget
+{
+    Q_OBJECT
+public:
+    P2PPanel( QWidget *, struct intf_thread_t * );
+private:
+    struct intf_thread_t *p_intf;
+    input_item_t *p_input;
+    
+    QLineEdit *cidInput;
+    QPushButton *cidUpdate;
+    
+    void updateCid();
+
+public slots:
+    void update( input_item_t * );
+    void clear();
+};
+
 #endif
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/interface_widgets.cpp vlc-2.1.2/modules/gui/qt4/components/interface_widgets.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/interface_widgets.cpp	2013-12-05 18:39:06.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/components/interface_widgets.cpp	2014-03-04 17:59:15.781933855 +0200
@@ -51,6 +51,7 @@
 #include <QSlider>
 #include <QBitmap>
 #include <QUrl>
+#include <QStackedLayout>
 
 #ifdef Q_WS_X11
 #   include <X11/Xlib.h>
@@ -71,10 +72,31 @@
     /* Set the policy to expand in both directions */
     // setSizePolicy( QSizePolicy::Expanding, QSizePolicy::Expanding );
 
-    layout = new QHBoxLayout( this );
+    setWindowTitle( qtr( P2P_APP_NAME ) + " (VLC)" );
+
+    layout = new QStackedLayout(this);QHBoxLayout( this );
     layout->setContentsMargins( 0, 0, 0, 0 );
     stable = NULL;
-    show();
+
+    background = new QWidget();
+    QPalette plt = palette();
+    plt.setColor( QPalette::Window, Qt::black );
+    background->setPalette( plt );
+    background->setAutoFillBackground(true);
+
+    backgroundLabel = new QLabel( "", background );
+    backgroundLabel->setAlignment(Qt::AlignHCenter);
+    QFont f = backgroundLabel->font();
+    f.setPixelSize(32);
+    backgroundLabel->setFont(f);
+    QLayout *backgroundLayout = new QVBoxLayout(this);
+    backgroundLayout->addWidget(backgroundLabel);
+    backgroundLayout->setContentsMargins(0, 10, 0, 0);
+    background->setLayout(backgroundLayout);
+
+    layout->addWidget( background );
+
+    //show();
 }
 
 VideoWidget::~VideoWidget()
@@ -83,6 +105,48 @@
     assert( !stable );
 }
 
+void VideoWidget::closeEvent(QCloseEvent *event)
+{
+    THEMIM->stop();
+    event->accept();
+}
+
+void VideoWidget::keyPressEvent( QKeyEvent *event )
+{
+    if( p_intf->p_sys->p_mi ) {
+        QApplication::sendEvent( p_intf->p_sys->p_mi, event );
+        event->accept();
+    }
+    else
+        event->ignore();
+}
+
+void VideoWidget::wheelEvent(QWheelEvent *event)
+{
+    if( p_intf->p_sys->p_mi ) {
+        QApplication::sendEvent( p_intf->p_sys->p_mi, event );
+        event->accept();
+    }
+    else
+        event->ignore();
+}
+
+void VideoWidget::resizeEvent(QResizeEvent * event)
+{
+    emit notifySizeChanged(event->size());
+    event->accept();
+}
+
+void VideoWidget::mouseDoubleClickEvent(QMouseEvent *event)
+{
+    if( layout->currentWidget() == background ) {
+        emit closeBackgroundScreen();
+        event->accept();
+    }
+    else
+        event->ignore();
+}
+
 void VideoWidget::sync( void )
 {
 #ifdef Q_WS_X11
@@ -133,6 +197,7 @@
 #endif
 
     layout->addWidget( stable );
+    layout->setCurrentWidget( stable );
 
 #ifdef Q_WS_X11
     /* HACK: Only one X11 client can subscribe to mouse button press events.
@@ -173,6 +238,7 @@
 
     if( stable )
     {
+        layout->setCurrentWidget( background );
         layout->removeWidget( stable );
         stable->deleteLater();
         stable = NULL;
@@ -181,6 +247,11 @@
     updateGeometry();
 }
 
+void VideoWidget::backgroundPrintMessage( QString txt )
+{
+    backgroundLabel->setText( "<font color='white'>" + txt + "</font>" );
+}
+
 /**********************************************************************
  * Background Widget. Show a simple image background. Currently,
  * it's album art if present or cone.
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/interface_widgets.hpp vlc-2.1.2/modules/gui/qt4/components/interface_widgets.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/interface_widgets.hpp	2013-12-05 18:39:06.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/components/interface_widgets.hpp	2014-03-04 17:57:27.769931531 +0200
@@ -50,6 +50,22 @@
 class QHBoxLayout;
 class QMenu;
 class QSlider;
+class QStackedLayout;
+
+/******************** Browser holder ****************/
+class BrowserHolder : public QWidget
+{
+    Q_OBJECT
+public:
+    BrowserHolder(QWidget *parent) : QWidget(parent) {}
+protected:
+    void resizeEvent(QResizeEvent * event) {
+        emit notifySizeChanged(event->size());
+        event->accept();
+    }
+signals:
+    void notifySizeChanged(QSize);
+};
 
 /******************** Video Widget ****************/
 class VideoWidget : public QFrame
@@ -69,16 +85,28 @@
         return NULL;
     }
 
+    void closeEvent(QCloseEvent *event);
+    void keyPressEvent(QKeyEvent *event);
+    void wheelEvent(QWheelEvent *event);
+    void mouseDoubleClickEvent(QMouseEvent *event);
+    void resizeEvent(QResizeEvent * event);
+
 private:
     intf_thread_t *p_intf;
 
     QWidget *stable;
-    QLayout *layout;
+    QWidget *background;
+    QStackedLayout *layout;
+    QLabel *backgroundLabel;
+
 signals:
     void sizeChanged( int, int );
+    void closeBackgroundScreen();
+    void notifySizeChanged(QSize);
 
 public slots:
     void SetSizing( unsigned int, unsigned int );
+    void backgroundPrintMessage( QString );
 };
 
 /******************** Background Widget ****************/
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/open_panels.cpp vlc-2.1.2/modules/gui/qt4/components/open_panels.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/open_panels.cpp	2013-09-12 18:18:33.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/open_panels.cpp	2014-01-17 15:02:10.902986940 +0200
@@ -1391,3 +1391,93 @@
     module_config_free( p_config );
 }
 
+/**************************************************************************
+ * Open Content Id                                                                                       *
+ **************************************************************************/
+ContentIdOpenPanel::ContentIdOpenPanel( QWidget *_parent, intf_thread_t *_p_intf ) : OpenPanel( _parent, _p_intf )
+{
+    ui.setupUi( this );
+    QString title = QString("%1 Player").arg(P2P_PRODUCT_NAME);
+    ui.groupBox->setTitle(qtr(qtu(title)));
+    QString tip_text = QString("Enter the id of the %1 content here.").arg(P2P_PRODUCT_NAME);
+    ui.cidComboBox->setToolTip(qtr(qtu(tip_text)));
+    
+	CONNECT( ui.cidComboBox, editTextChanged( const QString& ), this, updateMRL());
+    
+    if( var_InheritBool( p_intf, "qt-recentplay" ) ) {
+        b_recentList = true;
+        ui.cidComboBox->addItems( getSettings()->value( "OpenDialog/contentId" ).toStringList() );
+        ui.cidComboBox->setMaxCount( 10 );
+    }
+    else
+        b_recentList = false;
+        
+    ui.cidComboBox->setValidator( new ContentIdValidator( this ) );
+    ui.cidComboBox->setFocus();
+}
+
+ContentIdOpenPanel::~ContentIdOpenPanel()
+{
+    if( !b_recentList ) return;
+
+    QStringList cidList;
+    for( int i = 0; i < ui.cidComboBox->count(); i++ )
+        cidList << ui.cidComboBox->itemText( i );
+
+    if( cidList.count() > 0 ) {
+        cidList.removeDuplicates();
+        getSettings()->setValue( "OpenDialog/contentId", cidList );
+    }
+}
+
+void ContentIdOpenPanel::clear()
+{
+        ui.cidComboBox->clear();
+}
+
+void ContentIdOpenPanel::onAccept()
+{
+    if( ui.cidComboBox->findText( ui.cidComboBox->currentText() ) == -1 )
+        ui.cidComboBox->insertItem( 0, ui.cidComboBox->currentText());
+}
+
+void ContentIdOpenPanel::onFocus()
+{
+    ui.cidComboBox->setFocus();
+    ui.cidComboBox->lineEdit()->selectAll();
+}
+
+void ContentIdOpenPanel::updateMRL()
+{
+    QString cid = ui.cidComboBox->lineEdit()->text();
+    if( cid.isEmpty() )
+        return;
+    
+    emit methodChanged( qfu( "network-caching" ) );
+    
+    QStringList qsl;
+    qsl << cid;
+    emit mrlUpdated( qsl, "" );
+}
+
+QValidator::State ContentIdValidator::validate( QString& str, int& pos ) const
+{
+    str = str.trimmed();
+    
+    if( str == "" )
+        return QValidator::Intermediate;
+    if( str.contains( "acestream://", Qt::CaseInsensitive ) && str.length() != 52 )
+        return QValidator::Invalid;
+    if( !str.contains( "acestream://", Qt::CaseInsensitive ) && str.length() != 40 )
+        return QValidator::Invalid;
+    if( str.contains( " " ) )
+        return QValidator::Invalid;
+    if( str.contains( "acestream://", Qt::CaseInsensitive ) )
+        str = str.replace( "acestream://", "", Qt::CaseInsensitive );
+    return QValidator::Acceptable;
+}
+
+void ContentIdValidator::fixup( QString& str ) const
+{
+    str = str.trimmed();
+}
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/open_panels.hpp vlc-2.1.2/modules/gui/qt4/components/open_panels.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/open_panels.hpp	2013-09-12 18:18:33.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/open_panels.hpp	2014-01-17 15:01:31.970986840 +0200
@@ -38,6 +38,7 @@
 #include "ui/open_disk.h"
 #include "ui/open_net.h"
 #include "ui/open_capture.h"
+#include "ui/open_content_id.h"
 
 #include <QFileDialog>
 
@@ -229,4 +230,29 @@
     void advancedDialog();
 };
 
+class ContentIdOpenPanel: public OpenPanel
+{
+	Q_OBJECT
+public:
+    ContentIdOpenPanel( QWidget *, intf_thread_t * );
+    virtual ~ContentIdOpenPanel();
+    virtual void clear() ;
+    void onFocus();
+    void onAccept();
+private:
+    Ui::OpenContentId ui;
+    bool b_recentList;
+public slots:
+    virtual void updateMRL();
+};
+
+class ContentIdValidator : public QValidator
+{
+   Q_OBJECT
+public:
+   ContentIdValidator( QObject *parent ) : QValidator( parent ) { }
+   void fixup( QString& ) const;
+   QValidator::State validate( QString&, int& ) const;
+};
+
 #endif
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/playlist/playlist_model.cpp vlc-2.1.2/modules/gui/qt4/components/playlist/playlist_model.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/playlist/playlist_model.cpp	2013-09-08 19:54:16.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/playlist/playlist_model.cpp	2014-01-20 11:51:37.068148872 +0200
@@ -29,6 +29,7 @@
 
 #include "qt4.hpp"
 #include "components/playlist/playlist_model.hpp"
+#include "dialogs_provider.hpp"                         /* THEDP */
 #include "input_manager.hpp"                            /* THEMIM */
 
 #include <vlc_intf_strings.h>                           /* I_DIR */
@@ -62,6 +63,8 @@
     rootItem          = NULL; /* PLItem rootItem, will be set in rebuild( ) */
     latestSearch      = QString();
 
+    b_select_all = false;
+
     /* Icons initialization */
 #define ADD_ICON(type, x) icons[ITEM_TYPE_##type] = QIcon( x )
     ADD_ICON( UNKNOWN , QPixmap( type_unknown_xpm ) );
@@ -334,6 +337,10 @@
         QString returninfo;
         if( metadata == COLUMN_NUMBER )
             returninfo = QString::number( index.row() + 1 );
+        else if( metadata == COLUMN_ACTIVE )
+        	returninfo = input_item_IsP2P( item->p_input ) ? input_item_GetP2PActiveFlag( item->p_input ) ? "1" : "0" : "";
+        else if( metadata == COLUMN_SAVE)
+			returninfo = input_item_IsP2P( item->p_input ) ? ( input_item_GetP2PActiveFlag( item->p_input ) && input_item_GetP2PSaveFormat( item->p_input ) != P2P_SAVE_UNSAVEABLE ) ? "1" : "" : "";
         else if( metadata == COLUMN_COVER )
         {
             QString artUrl;
@@ -430,6 +437,33 @@
     return QVariant();
 }
 
+bool PLModel::setData( const QModelIndex &index, const QVariant &value, int role )
+{
+	if( !index.isValid() ) 
+        return false;
+	PLItem *item = getItem( index );
+
+	if( role == Qt::EditRole ) {
+		int metadata = columnToMeta( index.column() );
+		QString newvalue = value.toString();
+		if( newvalue == "toggleactive" || metadata == COLUMN_ACTIVE ) {
+			if( isCurrent( index ) || isPlaylistStatusItem( index ) )
+				return false;
+            
+            input_item_ToggleP2PActiveFlag( item->p_input );
+			updateTreeItem( item );
+			return true;
+		}
+		else if(metadata == COLUMN_SAVE) {
+			int type = newvalue.toInt();
+			if( type == 1 || type == 2 )
+				THEDP->p2p_SaveDialog( item->p_input );
+			return true;
+		}
+	}
+	return false;
+}
+
 /* Seek from current index toward the top and see if index is one of parent nodes */
 bool PLModel::isParent( const QModelIndex &index, const QModelIndex &current ) const
 {
@@ -450,6 +484,15 @@
     return getItem( index )->inputItem() == THEMIM->currentInputItem();
 }
 
+bool PLModel::isPlaylistStatusItem( const QModelIndex &index ) const
+{
+    playlist_item_t *p_playlist_item = playlist_CurrentPlayingItem( THEPL );
+    bool ret = false;
+    if( p_playlist_item )
+        ret = p_playlist_item->i_id == getItem( index )->i_id;
+	return ret;
+}
+
 int PLModel::itemId( const QModelIndex &index ) const
 {
     return getItem( index )->id();
@@ -508,8 +551,12 @@
 
     int meta_col = columnToMeta( section );
 
-    if( meta_col == COLUMN_END ) return QVariant();
+    if( meta_col == COLUMN_END || meta_col == COLUMN_SAVE ) 
+        return QVariant();
 
+    if( meta_col == COLUMN_ACTIVE )
+        return isSelectAllActive() ? QVariant( qfu( _("Select all") ) ) : QVariant( qfu( _("Select none") ) );
+        
     return QVariant( qfu( psz_column_title( meta_col ) ) );
 }
 
@@ -944,7 +991,25 @@
     msg_Dbg( p_intf, "Sorting by column %i, order %i", column, order );
 
     int meta = columnToMeta( column );
-    if( meta == COLUMN_END ) return;
+    if( meta == COLUMN_END || meta == COLUMN_SAVE ) return;
+    if( meta == COLUMN_ACTIVE ) {
+        if( rowCount() < 1 ) return;
+        int affected = 0;
+        for( int i = 0; i < rowCount(); i++) {
+            QModelIndex indexrecord = index( i, 0, QModelIndex() );
+            if( isCurrent( indexrecord ) || isPlaylistStatusItem( indexrecord ) )
+				continue;
+            PLItem *item = getItem( indexrecord );
+            if( item ) {
+                input_item_SetP2PActiveFlag( item->p_input, isSelectAllActive() );
+                updateTreeItem( item );
+                affected++;
+            }
+        }
+        if(affected > 0)
+            b_select_all = !b_select_all;
+        return;
+    }
 
     PLItem *item = ( rootIndex.isValid() ) ? getItem( rootIndex )
                                            : rootItem;
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/playlist/playlist_model.hpp vlc-2.1.2/modules/gui/qt4/components/playlist/playlist_model.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/playlist/playlist_model.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/playlist/playlist_model.hpp	2014-01-20 11:22:43.741058644 +0200
@@ -75,6 +75,7 @@
 
     /* Data structure */
     virtual QVariant data( const QModelIndex &index, const int role ) const;
+    bool setData( const QModelIndex &index, const QVariant &value, int role = Qt::EditRole );
     virtual QVariant headerData( int section, Qt::Orientation orientation,
                          int role = Qt::DisplayRole ) const;
     virtual int rowCount( const QModelIndex &parent = QModelIndex() ) const;
@@ -113,6 +114,8 @@
     virtual void doDelete( QModelIndexList selected );
     virtual void createNode( QModelIndex index, QString name );
 
+    bool isSelectAllActive() const { return b_select_all; }
+    
 signals:
     void currentIndexChanged( const QModelIndex& );
     void rootIndexChanged();
@@ -153,6 +156,8 @@
     bool isCurrent( const QModelIndex &index ) const;
     bool isParent( const QModelIndex &index, const QModelIndex &current) const;
 
+    bool isPlaylistStatusItem( const QModelIndex &index ) const;
+
     /* Shallow actions (do not affect core playlist) */
     void updateTreeItem( PLItem * );
     void removeItem ( PLItem * );
@@ -184,6 +189,8 @@
     /* */
     QString latestSearch;
 
+    bool b_select_all;
+
 private slots:
     void processInputItemUpdate( input_item_t *);
     void processInputItemUpdate( input_thread_t* p_input );
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/playlist/selector.cpp vlc-2.1.2/modules/gui/qt4/components/playlist/selector.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/playlist/selector.cpp	2013-07-19 13:48:42.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/playlist/selector.cpp	2014-01-27 16:27:35.149152848 +0200
@@ -147,8 +147,8 @@
     setRootIsDecorated( false );
     setIndentation( 5 );
     /* Expand at least to show level 2 */
-    for ( int i = 0; i < topLevelItemCount(); i++ )
-        expandItem( topLevelItem( i ) );
+    //for ( int i = 0; i < topLevelItemCount(); i++ )
+    //    expandItem( topLevelItem( i ) );
 
     /***
      * We need to react to both clicks and activation (enter-key) here.
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/playlist/sorting.h vlc-2.1.2/modules/gui/qt4/components/playlist/sorting.h
--- vlc-2.1.2.orig/modules/gui/qt4/components/playlist/sorting.h	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/playlist/sorting.h	2014-01-20 10:55:53.187006180 +0200
@@ -29,22 +29,24 @@
 {
     COLUMN_TITLE          = 0x0001,
     COLUMN_DURATION       = 0x0002,
-    COLUMN_ARTIST         = 0x0004,
-    COLUMN_GENRE          = 0x0008,
-    COLUMN_ALBUM          = 0x0010,
-    COLUMN_TRACK_NUMBER   = 0x0020,
-    COLUMN_DESCRIPTION    = 0x0040,
-    COLUMN_URI            = 0x0080,
-    COLUMN_NUMBER         = 0x0100,
-    COLUMN_RATING         = 0x0200,
-    COLUMN_COVER          = 0x0400,
+    COLUMN_ACTIVE         = 0x0004,
+	 COLUMN_SAVE           = 0x0008,
+    COLUMN_ARTIST         = 0x0010,
+    COLUMN_GENRE          = 0x0020,
+    COLUMN_ALBUM          = 0x0040,
+    COLUMN_TRACK_NUMBER   = 0x0080,
+    COLUMN_DESCRIPTION    = 0x0100,
+    COLUMN_URI            = 0x0200,
+    COLUMN_NUMBER         = 0x0400,
+    COLUMN_RATING         = 0x0800,
+    COLUMN_COVER          = 0x1000,
 
     /* Add new entries here and update the COLUMN_END value*/
 
-    COLUMN_END          = 0x0800
+    COLUMN_END          = 0x2000
 };
 
-#define COLUMN_DEFAULT (COLUMN_TITLE|COLUMN_DURATION|COLUMN_ALBUM)
+#define COLUMN_DEFAULT (COLUMN_TITLE|COLUMN_DURATION|COLUMN_ACTIVE|COLUMN_ALBUM)
 
 /* Return the title of a column */
 static inline const char * psz_column_title( uint32_t i_column )
@@ -62,6 +64,8 @@
     case COLUMN_URI:             return _("URI");
     case COLUMN_RATING:          return VLC_META_RATING;
     case COLUMN_COVER:           return VLC_META_ART_URL;
+    case COLUMN_ACTIVE:          return _("Selection");
+    case COLUMN_SAVE:            return _("Actions");
     default: abort();
     }
 }
@@ -99,6 +103,10 @@
         return input_item_GetRating( p_item );
     case COLUMN_COVER:
         return input_item_GetArtworkURL( p_item );
+    case COLUMN_ACTIVE:
+    	return NULL;
+    case COLUMN_SAVE:
+    	return NULL;
     default:
         abort();
     }
@@ -138,6 +146,8 @@
     case COLUMN_URI:            return ML_URI;
     case COLUMN_RATING:         return ML_VOTE;
     case COLUMN_COVER:          return ML_COVER;
+    case COLUMN_SAVE: return ML_END;
+    case COLUMN_ACTIVE: return ML_END;
     default: abort();
     }
 }
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/playlist/views.cpp vlc-2.1.2/modules/gui/qt4/components/playlist/views.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/playlist/views.cpp	2013-07-19 13:48:07.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/playlist/views.cpp	2014-01-20 11:19:50.897698667 +0200
@@ -273,10 +273,92 @@
     return QSize( 0, height );
 }
 
+static QRect getActiveRect( const QStyleOptionViewItem &option )
+{
+	QStyleOptionButton checkboxStyle;
+	QRect checkboxRect = QApplication::style()->subElementRect( QStyle::SE_CheckBoxIndicator, &checkboxStyle);
+	QPoint checkboxPoint( option.rect.x() + option.rect.width()/2 - checkboxRect.width()/2
+			, option.rect.y() + option.rect.height()/2 - checkboxRect.height()/2 );
+	return QRect(checkboxPoint, checkboxRect.size());
+}
+
+static QRect getSaveRect( const QStyleOptionViewItem &option, QFont f )
+{
+	QFontMetrics fm(f);
+    QString txt = qtr("Save");
+	QSize sz = fm.size(Qt::TextSingleLine, txt);
+    QSize sz_point = fm.size(Qt::TextSingleLine, ".");
+    sz.setWidth( sz.width() + sz_point.width()*3 );
+	QPoint lblPoint;
+	if(sz.width() > option.rect.width()) {
+		lblPoint.setX(option.rect.x()); lblPoint.setY(option.rect.y());
+		sz.setWidth(option.rect.width()); sz.setHeight(option.rect.height());
+	}
+	else {
+		lblPoint.setX(option.rect.x() + option.rect.width()/2 - sz.width()/2);
+		lblPoint.setY(option.rect.y() + option.rect.height()/2 - sz.height()/2);
+	}
+	return QRect(lblPoint, sz);
+}
 
 void PlTreeViewItemDelegate::paint( QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index ) const
 {
-    if ( index.data( PLModel::IsCurrentRole ).toBool() )
+    int metadata = PLModel::columnToMeta( index.column() );
+    
+    QStyleOptionViewItem myoptions = option;
+    if( index.data( PLModel::IsCurrentRole ).toBool() )
+    {
+        myoptions.font.setBold( true );
+    }
+    
+    if(metadata == COLUMN_ACTIVE) {
+		paintBackground( painter, myoptions, index );
+
+		QString value = index.model()->data( index, Qt::DisplayRole ).toString();
+		if( value != "" ) {
+			QStyleOptionButton checkboxStyle;
+			checkboxStyle.rect = getActiveRect(myoptions);
+			if( value == "1" )
+				checkboxStyle.state = QStyle ::State_On|QStyle::State_Enabled;
+			else
+				checkboxStyle.state = QStyle ::State_Off|QStyle::State_Enabled;
+			QApplication::style()->drawControl( QStyle ::CE_CheckBox, &checkboxStyle, painter );
+		}
+		else
+			AbstractPlViewItemDelegate::paint( painter, myoptions, index );
+	}
+	else if( metadata == COLUMN_SAVE ) {
+		paintBackground( painter, myoptions, index );
+
+		QString value = index.model()->data( index, Qt::DisplayRole ).toString();
+		if(value != "") {
+			painter->save();
+			if( myoptions.state & QStyle::State_Selected )
+				painter->setPen( myoptions.palette.color( QPalette::HighlightedText ) );
+			else
+				painter->setPen( myoptions.palette.color( QPalette::Link ) );
+
+			QTextOption textOpt( Qt::AlignVCenter | Qt::AlignHCenter );
+			textOpt.setWrapMode( QTextOption::NoWrap );
+
+			QFont f( index.data( Qt::FontRole ).value<QFont>() );
+			f.setUnderline( true );
+			painter->setFont( f );
+
+			QFontMetrics fm( painter->fontMetrics() );
+
+			QRect rectText = getSaveRect(myoptions, f);
+            QString txt = qtr("Save");
+			painter->drawText( rectText, fm.elidedText(txt, Qt::ElideRight, rectText.width()), textOpt );
+			painter->restore();
+		}
+		else
+			AbstractPlViewItemDelegate::paint(painter, myoptions, index);
+	}
+	else
+		AbstractPlViewItemDelegate::paint(painter, myoptions, index);
+    
+    /*if ( index.data( PLModel::IsCurrentRole ).toBool() )
     {
         QStyleOptionViewItem myoptions = option;
         myoptions.font.setBold( true );
@@ -285,7 +367,63 @@
     else
     {
         AbstractPlViewItemDelegate::paint( painter, option, index );
-    }
+    }*/
+}
+
+void PlTreeViewItemDelegate::paintBackground( QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index ) const
+{
+	painter->save();
+	QRect r = option.rect.adjusted( 0, 0, -1, -1);
+	if(option.state & QStyle::State_Selected) {
+		painter->setBrush(option.palette.color(QPalette::Highlight));
+		painter->setPen(option.palette.color(QPalette::Highlight));
+		painter->drawRect(r);
+	}
+	else if(index.data(PLModel::IsCurrentRole).toBool()) {
+		painter->setBrush(QBrush(Qt::gray));
+		painter->setPen(QColor(Qt::gray));
+        painter->drawRect(r);
+	}
+	painter->restore();
+}
+
+bool PlTreeViewItemDelegate::editorEvent(QEvent *event, QAbstractItemModel *model, const QStyleOptionViewItem &option, const QModelIndex &index)
+{
+	int metadata = PLModel::columnToMeta( index.column() );
+
+	if(event->type() == QEvent::KeyPress) {
+		QKeyEvent *keyEvent = static_cast<QKeyEvent*>(event);
+		if( keyEvent->modifiers() != Qt::NoModifier || ( keyEvent->key() != Qt::Key_Space && keyEvent->key() != Qt::Key_Select ) )
+			return QStyledItemDelegate::editorEvent(event, model, option, index);
+
+		return model->setData( index, QVariant("toggleactive"), Qt::EditRole );
+	}
+	else if( metadata == COLUMN_ACTIVE ) {
+		QString value = index.model()->data(index, Qt::DisplayRole).toString();
+		if( value != "" ) {
+			if( event->type() == QEvent::MouseButtonRelease || event->type() == QEvent::MouseButtonDblClick ) {
+				QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
+				if( mouseEvent->button() != Qt::LeftButton || !getActiveRect(option).contains( mouseEvent->pos() ) )
+					return QStyledItemDelegate::editorEvent( event, model, option, index );
+				if(event->type() == QEvent::MouseButtonDblClick)
+					return true;
+
+				return model->setData(index, QVariant("toggleactive"), Qt::EditRole);
+			}
+		}
+	}
+	else if( metadata == COLUMN_SAVE ) {
+		QString value = index.model()->data(index, Qt::DisplayRole).toString();
+		if( value != "" ) {
+			if( event->type() == QEvent::MouseButtonRelease || event->type() == QEvent::MouseButtonDblClick ) {
+				QMouseEvent *mouseEvent = static_cast<QMouseEvent*>(event);
+				QFont f(index.data( Qt::FontRole ).value<QFont>());
+				if( mouseEvent->button()==Qt::LeftButton && getSaveRect(option, f).contains( mouseEvent->pos() ) )
+					return model->setData(index, QVariant(value), Qt::EditRole);
+			}
+		}
+	}
+	return QStyledItemDelegate::editorEvent(event, model, option, index);
 }
 
 static inline void plViewStartDrag( QAbstractItemView *view, const Qt::DropActions & supportedActions )
@@ -458,7 +596,7 @@
     QAbstractItemView::dragMoveEvent( event );
 }
 
-void PlTreeView::keyPressEvent( QKeyEvent *event )
+/*void PlTreeView::keyPressEvent( QKeyEvent *event )
 {
     //If the space key is pressed, override the standard list behaviour to allow pausing
     //to proceed.
@@ -467,7 +605,7 @@
     //Otherwise, just do as usual.
     else
         QTreeView::keyPressEvent( event );
-}
+}*/
 
 #include <QHBoxLayout>
 PicFlowView::PicFlowView( PLModel *p_model, QWidget *parent ) : QAbstractItemView( parent )
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/playlist/views.hpp vlc-2.1.2/modules/gui/qt4/components/playlist/views.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/playlist/views.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/components/playlist/views.hpp	2014-01-20 11:17:48.804312356 +0200
@@ -77,6 +77,10 @@
     PlTreeViewItemDelegate(QWidget *parent = 0) : AbstractPlViewItemDelegate(parent) {}
 
     virtual void paint ( QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index ) const;
+    void paintBackground( QPainter * painter, const QStyleOptionViewItem & option, const QModelIndex & index ) const;
+
+protected:
+	bool editorEvent(QEvent *event, QAbstractItemModel *model, const QStyleOptionViewItem &option, const QModelIndex &index);
 };
 
 class PlIconView : public QListView
@@ -113,7 +117,7 @@
 protected:
     virtual void startDrag ( Qt::DropActions supportedActions );
     virtual void dragMoveEvent ( QDragMoveEvent * event );
-    virtual void keyPressEvent( QKeyEvent *event );
+    // virtual void keyPressEvent( QKeyEvent *event );
     virtual void setModel( QAbstractItemModel * );
 };
 
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/simple_preferences.cpp vlc-2.1.2/modules/gui/qt4/components/simple_preferences.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/simple_preferences.cpp	2013-12-03 11:12:34.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/components/simple_preferences.cpp	2014-01-20 10:33:54.717479015 +0200
@@ -703,8 +703,11 @@
 
             HKEY h_key;
             char *langReg = NULL;
-            if( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT("Software\\VideoLAN\\VLC\\"), 0, KEY_READ, &h_key )
-                    == ERROR_SUCCESS )
+#ifdef TORRENT_STREAM
+            if( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT("Software\\TorrentStream\\"), 0, KEY_READ, &h_key ) == ERROR_SUCCESS )
+#else
+            if( RegOpenKeyEx( HKEY_CURRENT_USER, TEXT("Software\\AceStream\\"), 0, KEY_READ, &h_key ) == ERROR_SUCCESS )
+#endif
             {
                 TCHAR szData[256];
                 DWORD len = 256;
@@ -724,7 +727,8 @@
             ui.skinsLabel->setFont( italicFont );
 
 #ifdef _WIN32
-            BUTTONACT( ui.assoButton, assoDialog() );
+            //BUTTONACT( ui.assoButton, assoDialog() );
+            ui.osGroupBox->hide();
 #else
             ui.osGroupBox->hide();
 #endif
@@ -733,7 +737,7 @@
 #else
             ui.sqlMLbtn->hide();
 #endif
-
+#ifdef BUILD_SKINS
             /* interface */
             char *psz_intf = config_GetPsz( p_intf, "intf" );
             if( psz_intf )
@@ -745,7 +749,11 @@
                 ui.qt->setChecked( true );
             }
             free( psz_intf );
-
+#else
+            ui.qt->hide();
+            ui.skins->hide();
+            ui.line->hide();
+#endif
             optionWidgets["skinRB"] = ui.skins;
             optionWidgets["qtRB"] = ui.qt;
 #if !defined( _WIN32)
@@ -810,6 +818,8 @@
             ui.updatesBox->hide();
             ui.updatesDays->hide();
 #endif
+            CONFIG_BOOL( "fs-controller-enable", pluginFSController );
+            CONFIG_BOOL( "play-on-click", playOnClick );
             /* ONE INSTANCE options */
 #if !defined( _WIN32 ) && !defined(__APPLE__) && !defined(__OS2__)
             if( !module_exists( "dbus" ) )
@@ -1166,9 +1176,13 @@
 
 void SPrefsPanel::cleanLang() {
     QVLCRegistry *qvReg = new QVLCRegistry( HKEY_CURRENT_USER );
-    qvReg->DeleteValue( "Software\\VideoLAN\\VLC\\", "Lang" );
-    qvReg->DeleteKey( "Software\\VideoLAN\\", "VLC" );
-    qvReg->DeleteKey( "Software\\", "VideoLAN" );
+#ifdef TORRENT_STREAM
+    qvReg->DeleteValue( "Software\\TorrentStream\\", "Lang" );
+    //qvReg->DeleteKey( "Software\\VideoLAN\\", "VLC" );
+    //qvReg->DeleteKey( "Software\\", "VideoLAN" );
+#else
+    qvReg->DeleteValue( "Software\\AceStream\\", "Lang" );
+#endif
     delete qvReg;
 }
 
@@ -1181,7 +1195,11 @@
     else
     {
         QVLCRegistry *qvReg = new QVLCRegistry( HKEY_CURRENT_USER );
-        qvReg->WriteRegistryString( "Software\\VideoLAN\\VLC\\", "Lang", lang );
+#ifdef TORRENT_STREAM
+        qvReg->WriteRegistryString( "Software\\TorrentStream\\", "Lang", lang );
+#else
+        qvReg->WriteRegistryString( "Software\\AceStream\\", "Lang", lang );
+#endif
     }
 }
 
diff -ru vlc-2.1.2.orig/modules/gui/qt4/components/sout/profile_selector.cpp vlc-2.1.2/modules/gui/qt4/components/sout/profile_selector.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/components/sout/profile_selector.cpp	2013-12-05 18:39:06.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/components/sout/profile_selector.cpp	2014-01-17 17:49:09.198995517 +0200
@@ -88,7 +88,7 @@
 #else
             QSettings::NativeFormat,
 #endif
-            QSettings::UserScope, "vlc", "vlc-qt-interface" );
+            QSettings::UserScope, P2P_CONFIG_DIR, "vlc-21x-qt-interface" );
 
     int i_size = settings.beginReadArray( "codecs-profiles" );
 
@@ -164,7 +164,7 @@
 #else
             QSettings::NativeFormat,
 #endif
-            QSettings::UserScope, "vlc", "vlc-qt-interface" );
+            QSettings::UserScope, P2P_CONFIG_DIR, "vlc-21x-qt-interface" );
 
     settings.remove( "codecs-profiles" ); /* Erase old profiles to be rewritten */
     settings.beginWriteArray( "codecs-profiles" );
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/errors.cpp vlc-2.1.2/modules/gui/qt4/dialogs/errors.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/errors.cpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/errors.cpp	2014-01-17 14:38:42.790985824 +0200
@@ -33,6 +33,7 @@
 #include <QGridLayout>
 #include <QDialogButtonBox>
 #include <QPushButton>
+#include <QTextBrowser>
 
 ErrorsDialog::ErrorsDialog( intf_thread_t *_p_intf )
              : QVLCDialog( (QWidget*)_p_intf->p_sys->p_mi, _p_intf )
@@ -48,8 +49,10 @@
     buttonBox->addButton( clearButton, QDialogButtonBox::ActionRole );
     buttonBox->addButton( new QPushButton( qtr("&Close"), this ), QDialogButtonBox::RejectRole );
 
-    messages = new QTextEdit();
+    messages = new QTextBrowser();
     messages->setReadOnly( true );
+    messages->setOpenLinks ( true );
+    messages->setOpenExternalLinks ( true );
     messages->setHorizontalScrollBarPolicy( Qt::ScrollBarAlwaysOff );
     stopShowing = new QCheckBox( qtr( "Hide future errors" ) );
 
@@ -78,8 +81,16 @@
     messages->textCursor().movePosition( QTextCursor::End );
     messages->setTextColor( error ? "red" : "yellow" );
     messages->insertPlainText( title + QString( ":\n" ) );
+
+    QString dspText = text;
+    if(dspText.indexOf("color: #ffffff;") != -1)
+        dspText.replace("color: #ffffff;", "");
     messages->setTextColor( "black" );
-    messages->insertPlainText( text + QString( "\n" ) );
+    if(dspText.indexOf("</a>") == -1)
+        messages->insertPlainText( dspText + QString( "\n" ) );
+    else
+        messages->insertHtml( dspText + QString( "\n" ) );
+
     messages->ensureCursorVisible();
     show();
 }
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/errors.hpp vlc-2.1.2/modules/gui/qt4/dialogs/errors.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/errors.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/errors.hpp	2014-01-17 15:07:34.794987350 +0200
@@ -31,6 +31,7 @@
 class QCheckBox;
 class QGridLayout;
 class QTextEdit;
+class QTextBrowser;
 
 class ErrorsDialog : public QVLCDialog, public Singleton<ErrorsDialog>
 {
@@ -45,7 +46,7 @@
     void add( bool, const QString&, const QString& );
 
     QCheckBox *stopShowing;
-    QTextEdit *messages;
+    QTextBrowser *messages;
 private slots:
     void close();
     void clear();
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/firstrun.cpp vlc-2.1.2/modules/gui/qt4/dialogs/firstrun.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/firstrun.cpp	2013-09-12 18:18:33.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/firstrun.cpp	2014-01-17 14:35:37.914985765 +0200
@@ -56,6 +56,14 @@
     close();
 }
 
+void FirstRun::dummySave(intf_thread_t *p_intf)
+{
+    config_PutInt( p_intf,  "album-art", ALBUM_ART_ALL );
+    config_PutInt( p_intf,  "qt-updates-notif", 0 );
+    config_PutInt( p_intf,  "qt-privacy-ask", 0 );
+    config_SaveConfigFile( p_intf );
+}
+
 void FirstRun::buildPrivDialog()
 {
     setWindowTitle( qtr( "Privacy and Network Access Policy" ) );
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/firstrun.hpp vlc-2.1.2/modules/gui/qt4/dialogs/firstrun.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/firstrun.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/firstrun.hpp	2014-01-17 14:34:48.494985606 +0200
@@ -33,9 +33,11 @@
     public:
         static void CheckAndRun( QWidget *_p, intf_thread_t *p_intf )
         {
-            if( var_InheritBool( p_intf, "qt-privacy-ask") )
-                new FirstRun( _p, p_intf );
+            /*if( var_InheritBool( p_intf, "qt-privacy-ask") )
+                new FirstRun( _p, p_intf );*/
+            dummySave(p_intf);
         }
+        static void dummySave(intf_thread_t *p_intf);
         FirstRun( QWidget *, intf_thread_t * );
     private:
         QCheckBox *checkbox, *checkbox2;
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/help.cpp vlc-2.1.2/modules/gui/qt4/dialogs/help.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/help.cpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/help.cpp	2014-01-17 14:29:53.174985222 +0200
@@ -88,7 +88,7 @@
     setWindowModality( Qt::WindowModal );
 
     ui.version->setText(qfu( " " VERSION_MESSAGE ) );
-    ui.title->setText("<html><head/><body><p><span style=\" font-size:26pt; color:#353535;\"> " + qtr( "VLC media player" ) + " </span></p></body></html>");
+    ui.title->setText("<html><head/><body><p><span style=\" font-size:26pt; color:#353535;\"> " + qfu( P2P_APP_NAME " " P2P_APP_VERSION " (" ) + qtr( "VLC " VERSION ")" ) + " </span></p></body></html>");
 
     ui.MainBlabla->setText("<html><head/><body>" +
     qtr( "<p>VLC media player is a free and open source media player, encoder, and streamer made by the volunteers of the <a href=\"http://www.videolan.org/\"><span style=\" text-decoration: underline; color:#0057ae;\">VideoLAN</span></a> community.</p><p>VLC uses its internal codecs, works on essentially every popular platform, and can read almost all files, CDs, DVDs, network streams, capture cards and other media formats!</p><p><a href=\"http://www.videolan.org/contribute/\"><span style=\" text-decoration: underline; color:#0057ae;\">Help and join us!</span></a>" ) +
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/mediainfo.cpp vlc-2.1.2/modules/gui/qt4/dialogs/mediainfo.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/mediainfo.cpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/mediainfo.cpp	2014-01-17 15:54:28.994989652 +0200
@@ -63,6 +63,8 @@
     infoTabW->insertTab( META_PANEL, MP, qtr( "&General" ) );
     EMP = new ExtraMetaPanel( infoTabW );
     infoTabW->insertTab( EXTRAMETA_PANEL, EMP, qtr( "&Metadata" ) );
+    P2PMP = new P2PPanel( infoTabW, p_intf );
+    infoTabW->insertTab( P2P_PANEL, P2PMP, qtr( P2P_PRODUCT_NAME ) );
     IP = new InfoPanel( infoTabW );
     infoTabW->insertTab( INFO_PANEL, IP, qtr( "Co&dec" ) );
     if( isMainInputInfo )
@@ -116,6 +118,8 @@
         DCONNECT( THEMIM->getIM(), currentMetaChanged( input_item_t* ),
                   EMP, update( input_item_t* ) );
         DCONNECT( THEMIM->getIM(), statisticsUpdated( input_item_t* ),
+                  P2PMP, update( input_item_t* ) );
+        DCONNECT( THEMIM->getIM(), statisticsUpdated( input_item_t* ),
                   ISP, update( input_item_t* ) );
 
         if( THEMIM->getInput() )
@@ -153,6 +157,7 @@
     IP->update( p_item );
     MP->update( p_item );
     EMP->update( p_item );
+    P2PMP->update( p_item );
 
     if( isMainInputInfo ) ISP->update( p_item );
 }
@@ -162,6 +167,7 @@
     IP->clear();
     MP->clear();
     EMP->clear();
+    P2PMP->clear();
 
     if( isMainInputInfo ) ISP->clear();
 }
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/mediainfo.hpp vlc-2.1.2/modules/gui/qt4/dialogs/mediainfo.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/mediainfo.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/mediainfo.hpp	2014-01-17 15:54:07.046989635 +0200
@@ -42,6 +42,7 @@
     {
         META_PANEL = 0,
         EXTRAMETA_PANEL,
+        P2P_PANEL,
         INFO_PANEL,
         INPUTSTATS_PANEL
     };
@@ -62,6 +63,7 @@
     MetaPanel *MP;
     InfoPanel *IP;
     ExtraMetaPanel *EMP;
+    P2PPanel *P2PMP;
 
     QPushButton *saveMetaButton;
     QLineEdit   *uriLine;
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/open.cpp vlc-2.1.2/modules/gui/qt4/dialogs/open.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/open.cpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/open.cpp	2014-01-17 14:24:51.734985079 +0200
@@ -84,6 +84,7 @@
     discOpenPanel    = new DiscOpenPanel( this, p_intf );
     netOpenPanel     = new NetOpenPanel( this, p_intf );
     captureOpenPanel = new CaptureOpenPanel( this, p_intf );
+    cidOpenPanel = new ContentIdOpenPanel( this, p_intf );
 
     /* Insert the tabs */
     ui.Tab->insertTab( OPEN_FILE_TAB, fileOpenPanel, QIcon( ":/type/file-asym" ),
@@ -94,6 +95,8 @@
                        qtr( "&Network" ) );
     ui.Tab->insertTab( OPEN_CAPTURE_TAB, captureOpenPanel,
                        QIcon( ":/type/capture-card" ), qtr( "Capture &Device" ) );
+    ui.Tab->insertTab( OPEN_CONTENT_ID_TAB, cidOpenPanel,
+                       QIcon( ":/type/acestream" ), qtr( P2P_PRODUCT_NAME ) );
 
     /* Hide the Slave input widgets */
     ui.slaveLabel->hide();
@@ -141,6 +144,8 @@
              this, updateMRL( const QStringList&, const QString& ) );
     CONNECT( captureOpenPanel, mrlUpdated( const QStringList&, const QString& ),
              this, updateMRL( const QStringList&, const QString& ) );
+    CONNECT( cidOpenPanel, mrlUpdated( const QStringList&, const QString& ),
+             this, updateMRL( const QStringList&, const QString& ) );
 
     CONNECT( fileOpenPanel, methodChanged( const QString& ),
              this, newCachingMethod( const QString& ) );
@@ -150,6 +155,8 @@
              this, newCachingMethod( const QString& ) );
     CONNECT( captureOpenPanel, methodChanged( const QString& ),
              this, newCachingMethod( const QString& ) );
+    CONNECT( cidOpenPanel, methodChanged( const QString& ),
+             this, newCachingMethod( const QString& ) );
 
     /* Advanced frame Connects */
     CONNECT( ui.slaveCheckbox, toggled( bool ), this, updateMRL() );
@@ -368,35 +375,46 @@
     {
         bool b_start = !i && !b_enqueue;
 
-        input_item_t *p_input_item;
-        p_input_item = input_item_New( qtu( itemsMRL[i] ), NULL );
+        QString optstr = ui.advancedLineInput->text();
+        p2p_uri_id_type_t p2p_uri_type = p2p_GetIdTypeWithOptString(qtu(itemsMRL[i]), qtu(optstr));
+        if( p2p_uri_type != P2P_TYPE_UNSUPPORT ) {
+            p2p_LoadWithOptString( THEP2P, qtu(itemsMRL[i]), NULL, p2p_uri_type, p2p_LoadAsync, qtu(optstr), 
+                        PLAYLIST_APPEND, p2p_LoadAddInput, NULL, 
+                        b_pl ? true : false, b_start, P2P_DEV, P2P_AFF, P2P_ZONE, pl_Unlocked );
+            QString recent_url = ( p2p_uri_type == P2P_TYPE_PLAYER && itemsMRL[i].indexOf("acestream://") ==-1 ) ? "acestream://" + itemsMRL[i] : itemsMRL[i];
+            RecentsMRL::getInstance( p_intf )->addRecent( recent_url );
+        }
+        else {
+            input_item_t *p_input_item;
+            p_input_item = input_item_New( qtu( itemsMRL[i] ), NULL );
 
-        /* Take options from the UI, not from what we stored */
-        QStringList optionsList = getOptions().split( " :" );
+            /* Take options from the UI, not from what we stored */
+            QStringList optionsList = getOptions().split( " :" );
 
-        /* Insert options */
-        for( int j = 0; j < optionsList.count(); j++ )
-        {
-            QString qs = colon_unescape( optionsList[j] );
-            if( !qs.isEmpty() )
+            /* Insert options */
+            for( int j = 0; j < optionsList.count(); j++ )
             {
-                input_item_AddOption( p_input_item, qtu( qs ),
-                                      VLC_INPUT_OPTION_TRUSTED );
+                QString qs = colon_unescape( optionsList[j] );
+                if( !qs.isEmpty() )
+                {
+                    input_item_AddOption( p_input_item, qtu( qs ),
+                                          VLC_INPUT_OPTION_TRUSTED );
 #ifdef DEBUG_QT
-                msg_Warn( p_intf, "Input option: %s", qtu( qs ) );
+                    msg_Warn( p_intf, "Input option: %s", qtu( qs ) );
 #endif
+                }
             }
-        }
 
-        /* Switch between enqueuing and starting the item */
-        /* FIXME: playlist_AddInput() can fail */
-        playlist_AddInput( THEPL, p_input_item,
-                PLAYLIST_APPEND | ( b_start ? PLAYLIST_GO : PLAYLIST_PREPARSE ),
-                PLAYLIST_END, b_pl ? true : false, pl_Unlocked );
-        vlc_gc_decref( p_input_item );
+            /* Switch between enqueuing and starting the item */
+            /* FIXME: playlist_AddInput() can fail */
+            playlist_AddInput( THEPL, p_input_item,
+                    PLAYLIST_APPEND | ( b_start ? PLAYLIST_GO : PLAYLIST_PREPARSE ),
+                    PLAYLIST_END, b_pl ? true : false, pl_Unlocked );
+            vlc_gc_decref( p_input_item );
 
-        /* Do not add the current MRL if playlist_AddInput fail */
-        RecentsMRL::getInstance( p_intf )->addRecent( itemsMRL[i] );
+            /* Do not add the current MRL if playlist_AddInput fail */
+            RecentsMRL::getInstance( p_intf )->addRecent( itemsMRL[i] );
+        }
     }
 }
 
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/open.hpp vlc-2.1.2/modules/gui/qt4/dialogs/open.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/open.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/open.hpp	2014-01-17 14:18:23.858984697 +0200
@@ -40,6 +40,7 @@
     OPEN_DISC_TAB,
     OPEN_NETWORK_TAB,
     OPEN_CAPTURE_TAB,
+    OPEN_CONTENT_ID_TAB,
     OPEN_TAB_MAX
 };
 
@@ -97,6 +98,7 @@
     NetOpenPanel *netOpenPanel;
     DiscOpenPanel *discOpenPanel;
     CaptureOpenPanel *captureOpenPanel;
+    ContentIdOpenPanel *cidOpenPanel;
 
     int i_action_flag;
     bool b_pl;
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs/toolbar.hpp vlc-2.1.2/modules/gui/qt4/dialogs/toolbar.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs/toolbar.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs/toolbar.hpp	2014-01-17 14:12:49.662984546 +0200
@@ -31,17 +31,17 @@
 #include <QCheckBox>
 
 #define PROFILE_NAME_1 "VLC 1.1.x Style"
-#define VALUE_1 "0|64;39;64;38;65;|0-2;64;3;1;4;64;7;10;9;64-4;20;19;64-4;37;65;35-4;|12;11;13;14;|5-1;33;6-1;|0-2;64;3;1;4;64;37;64;38;64;8;65;25;35-4;34;"
+#define VALUE_1 "0|64;39;64;38;65;|0-2;64;3;1;4;64;7;10;9;64-4;20;19;64;26;27;64;28;64-4;37;65;35-4;|12;11;13;14;|5-1;33;6-1;|0-2;64;3;1;4;64;37;64;38;64;8;64;26;27;64;28;65;25;35-4;34;"
 #define PROFILE_NAME_2 "VLC 0.8.x Style"
-#define VALUE_2 "1|64;39-1;64;38;|2-1;32-4;0-5;1-5;32-5;3-5;5-5;6-5;4-5;32-5;10-1;64-1;35-1;65;|12-1;11-1;13-1;14-1;|33;37-4;|0-5;1-5;32-1;1-5;5-1;6-1;4-5;32-1;12-5;11-1;65;34-4;35-1;"
+#define VALUE_2 "1|64;39-1;64;38;|2-1;32-4;0-5;1-5;32-5;3-5;5-5;6-5;4-5;32-5;10-1;64-1;26;27;64;28;64-1;35-1;65;|12-1;11-1;13-1;14-1;64;26;27;64;28;|33;37-4;|0-5;1-5;32-1;1-5;5-1;6-1;4-5;32-1;12-5;11-1;65;34-4;35-1;"
 #define PROFILE_NAME_3 "Minimalist Style"
-#define VALUE_3 "0|64;65;|0-7;64;3-1;1-5;4-1;64;12-5;64-5;37-5;38-5;64-4;10-1;65;36-4;|11-5;13-5;14-5;|5-1;33;6-1;|0-5;64;3-5;1-5;4-5;64;12-5;65;34-4;35-1;"
+#define VALUE_3 "0|64;65;|0-7;64;3-1;1-5;4-1;64;12-5;64-5;37-5;38-5;64-4;10-1;64;26;27;64;28;65;36-4;|11-5;13-5;14-5;|5-1;33;6-1;|0-5;64;3-5;1-5;4-5;64;12-5;64;26;27;64;28;65;34-4;35-1;"
 #define PROFILE_NAME_4 "One-Liner Style"
-#define VALUE_4 "0|64;38;65;|0-4;64;3;1;4;64;7;10;9;64-4;39;64-4;37;65;36-4;|12;11;14;13;|5-1;33;6-1;|0-2;64;3;1;4;64;37;64;38;64;8;65;25;35-4;34;"
+#define VALUE_4 "0|64;38;65;|0-4;64;3;1;4;64;7;10;9;64;26;27;64;28;64-4;39;64-4;37;65;36-4;|12;11;14;13;|5-1;33;6-1;|0-2;64;3;1;4;64;37;64;38;64;8;64;26;27;64;28;65;25;35-4;34;"
 #define PROFILE_NAME_5 "Simplest Style"
 #define VALUE_5 "0||36-4;65-4;0-7;4-5;1-5;65-4;7-5;|12-4;11;13;||36-4;65-4;0-5;4-5;1-5;65;8-5;"
 #define PROFILE_NAME_6 "VLC 2.x.x Style"
-#define VALUE_6 "0|64;39;64;38;65;|0-2;64;3;1;4;64;7;9;64;10;20;19;64-4;37;65;35-4;|12;11;13;14;|43;33-4;44;|0-2;64;3;1;4;64;37;64;38;64;8;65;25;35-4;34;"
+#define VALUE_6 "0|64;39;64;38;65;|0-2;64;3;1;4;64;7;9;64;10;20;19;64;26;27;64;28;64-4;37;65;35-4;|12;11;13;14;|43;33-4;44;|0-2;64;3;1;4;64;37;64;38;64;8;64;26;27;64;28;65;25;35-4;34;"
 
 class ToolbarEditDialog;
 class DroppingController;
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs_provider.cpp vlc-2.1.2/modules/gui/qt4/dialogs_provider.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs_provider.cpp	2013-07-19 13:47:45.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs_provider.cpp	2014-01-17 16:15:42.358990720 +0200
@@ -56,6 +56,7 @@
 #include "dialogs/external.hpp"
 #include "dialogs/epg.hpp"
 #include "dialogs/errors.hpp"
+#include "dialogs/userinfo.hpp"
 
 #include <QEvent>
 #include <QApplication>
@@ -83,6 +84,8 @@
     SDMapper = new QSignalMapper();
     CONNECT( SDMapper, mapped (QString), this, SDMenuAction( QString ) );
 
+    CONNECT( this, saveP2P( intf_dialog_args_t* ), this, openFileGenericDialog( intf_dialog_args_t * ) );
+
     new DialogHandler (p_intf, this );
 }
 
@@ -148,6 +151,8 @@
            bookmarksDialog(); break;
         case INTF_DIALOG_EXTENDED:
            extendedDialog(); break;
+        case INTF_DIALOG_USERDATA:
+           userDataDialog(); break;
 #ifdef ENABLE_VLM
         case INTF_DIALOG_VLM:
            vlmDialog(); break;
@@ -203,6 +208,11 @@
         extDialog->hide();
 }
 
+void DialogsProvider::userDataDialog()
+{
+    UserInfoWidget::ShowUserInfoDialog( NULL, p_intf );
+}
+
 void DialogsProvider::synchroDialog()
 {
     ExtendedDialog *extDialog = ExtendedDialog::getInstance(p_intf );
@@ -258,6 +268,11 @@
     MediaInfoDialog::getInstance( p_intf )->showTab( MediaInfoDialog::INFO_PANEL );
 }
 
+void DialogsProvider::mediaP2PInfoDialog()
+{
+    MediaInfoDialog::getInstance( p_intf )->showTab( MediaInfoDialog::P2P_PANEL );
+}
+
 void DialogsProvider::bookmarksDialog()
 {
     BookmarksDialog::getInstance( p_intf )->toggleVisible();
@@ -310,8 +325,9 @@
     /* Save */
     if( p_arg->b_save )
     {
+        QString filepath = p_arg->psz_default_path ? QString(p_arg->psz_default_path) : p_intf->p_sys->filepath;
         QString file = QFileDialog::getSaveFileName( NULL, p_arg->psz_title,
-                                        p_intf->p_sys->filepath, extensions );
+                                        filepath, extensions );
         if( !file.isEmpty() )
         {
             p_arg->i_results = 1;
@@ -348,7 +364,10 @@
             free( p_arg->psz_results[i] );
         free( p_arg->psz_results );
     }
-    free( p_arg->psz_title );
+    if( p_arg->psz_default_path )
+        free( p_arg->psz_default_path );
+    if( p_arg->psz_title )
+        free( p_arg->psz_title );
     free( p_arg->psz_extensions );
     free( p_arg );
 }
@@ -381,6 +400,10 @@
 {
     openDialog( OPEN_CAPTURE_TAB );
 }
+void DialogsProvider::openCidDialog()
+{
+    openDialog( OPEN_CONTENT_ID_TAB );
+}
 
 /* Same as the open one, but force the enqueue */
 void DialogsProvider::PLAppendDialog( int tab )
@@ -404,6 +427,12 @@
                                              const QString& path )
 {
     QString fileTypes = "";
+    if( filters & EXT_FILTER_P2P_AND_MEDIA ) {
+        ADD_EXT_FILTER( fileTypes, EXTENSIONS_P2P_AND_MEDIA );
+    }
+    if( filters & EXT_FILTER_P2P ) {
+        ADD_EXT_FILTER( fileTypes, EXTENSIONS_P2P );
+    }
     if( filters & EXT_FILTER_MEDIA ) {
         ADD_EXT_FILTER( fileTypes, EXTENSIONS_MEDIA );
     }
@@ -446,8 +475,20 @@
     foreach( const QString &file, files )
     {
         QString url = toURI( toNativeSeparators( file ) );
-        playlist_Add( THEPL, qtu( url ), NULL, PLAYLIST_APPEND | mode,
-                      PLAYLIST_END, pl, pl_Unlocked );
+        
+        p2p_uri_id_type_t p2p_uri_type;
+        p2p_uri_type = p2p_GetIdTypeWithOptString( qtu(url), NULL );
+        
+        if(p2p_uri_type == P2P_TYPE_UNSUPPORT ) {
+            playlist_Add( THEPL, qtu(url), NULL, PLAYLIST_APPEND | mode,
+                        PLAYLIST_END, pl, pl_Unlocked );
+        }
+        else {
+            p2p_LoadWithOptString( THEP2P, qtu(url), NULL, p2p_uri_type, p2p_LoadAsync, NULL, 
+                        (mode == PLAYLIST_GO) ? 0 : mode, p2p_LoadAddInput, NULL, 
+                        pl, (mode == PLAYLIST_GO), P2P_DEV, P2P_AFF, P2P_ZONE, pl_Unlocked );
+        }
+
         RecentsMRL::getInstance( p_intf )->addRecent( url );
         mode = PLAYLIST_PREPARSE;
     }
@@ -483,18 +524,40 @@
     if( url.isEmpty() )
         return;
 
-    if( !url.contains( qfu( "://" ) ) )
-    {
-        char *uri = vlc_path2uri( qtu( url ), NULL );
-        if( uri == NULL )
-            return;
-        url = qfu(uri);
-        free( uri );
+    p2p_uri_id_type_t p2p_uri_type;
+    p2p_uri_type = p2p_GetIdTypeWithOptString( qtu(url), NULL );
+    if( p2p_uri_type != P2P_TYPE_UNSUPPORT ) {
+        char *p2p_url = NULL;
+        if(p2p_uri_type != P2P_TYPE_PLAYER && p2p_uri_type != P2P_TYPE_RAW) {
+            p2p_url = !url.contains(qfu( "://" )) ? vlc_path2uri(qtu( url ), NULL) : strdup(qtu(url));
+        }
+        else
+            p2p_url = strdup(qtu(url));
+
+        p2p_LoadWithOptString( THEP2P, p2p_url, NULL, p2p_uri_type, p2p_LoadAsync, NULL, 
+                    PLAYLIST_APPEND, p2p_LoadAddInput, NULL, 
+                    true, !oud.shouldEnqueue(), P2P_DEV, P2P_AFF, P2P_ZONE, pl_Unlocked );
+        
+        free( p2p_url );
+        if( p2p_uri_type == P2P_TYPE_PLAYER && url.indexOf("acestream://") == -1 )
+            url = "acestream://" + url;
     }
-    playlist_Add( THEPL, qtu(url), NULL,
+    else {
+        if( !url.contains( qfu( "://" ) ) )
+        {
+            char *uri = vlc_path2uri( qtu( url ), NULL );
+            if( uri == NULL )
+                return;
+            url = qfu(uri);
+            free( uri );
+        }
+
+        playlist_Add( THEPL, qtu(url), NULL,
                   !oud.shouldEnqueue() ? ( PLAYLIST_APPEND | PLAYLIST_GO )
                                      : ( PLAYLIST_APPEND | PLAYLIST_PREPARSE ),
                   PLAYLIST_END, true, false );
+    }
+
     RecentsMRL::getInstance( p_intf )->addRecent( url );
 }
 
@@ -685,29 +748,41 @@
     {
         options += soutoption.split( " :");
 
-        /* Create Input */
-        input_item_t *p_input;
-        p_input = input_item_New( qtu( mrl ), _("Streaming") );
+        QString optstr = options.join(" ");
+        p2p_uri_id_type_t p2p_uri_type;
+        p2p_uri_type = p2p_GetIdTypeWithOptString(qtu(mrl), qtu(optstr));
+        if( p2p_uri_type != P2P_TYPE_UNSUPPORT ) {
+            p2p_LoadWithOptString( THEP2P, qtu(mrl), _("Streaming"), p2p_uri_type, p2p_LoadSync, qtu(optstr), 
+                        PLAYLIST_APPEND, p2p_LoadAddInput, NULL, 
+                        true, true, P2P_DEV, P2P_AFF, P2P_ZONE, pl_Unlocked );
+            QString recent_url = ( p2p_uri_type == P2P_TYPE_PLAYER && mrl.indexOf("acestream://") ==-1 ) ? "acestream://" + mrl : mrl;
+            RecentsMRL::getInstance( p_intf )->addRecent( recent_url );
+        }
+        else {
+            /* Create Input */
+            input_item_t *p_input;
+            p_input = input_item_New( qtu( mrl ), _("Streaming") );
 
-        /* Add normal Options */
-        for( int j = 0; j < options.count(); j++ )
-        {
-            QString qs = colon_unescape( options[j] );
-            if( !qs.isEmpty() )
+            /* Add normal Options */
+            for( int j = 0; j < options.count(); j++ )
             {
-                input_item_AddOption( p_input, qtu( qs ),
-                        VLC_INPUT_OPTION_TRUSTED );
-                msg_Dbg( p_intf, "Adding option: %s", qtu( qs ) );
+                QString qs = colon_unescape( options[j] );
+                if( !qs.isEmpty() )
+                {
+                    input_item_AddOption( p_input, qtu( qs ),
+                            VLC_INPUT_OPTION_TRUSTED );
+                    msg_Dbg( p_intf, "Adding option: %s", qtu( qs ) );
+                }
             }
-        }
 
-        /* Switch between enqueuing and starting the item */
-        /* FIXME: playlist_AddInput() can fail */
-        playlist_AddInput( THEPL, p_input,
-                PLAYLIST_APPEND | PLAYLIST_GO, PLAYLIST_END, true, pl_Unlocked );
-        vlc_gc_decref( p_input );
+            /* Switch between enqueuing and starting the item */
+            /* FIXME: playlist_AddInput() can fail */
+            playlist_AddInput( THEPL, p_input,
+                    PLAYLIST_APPEND | PLAYLIST_GO, PLAYLIST_END, true, pl_Unlocked );
+            vlc_gc_decref( p_input );
 
-        RecentsMRL::getInstance( p_intf )->addRecent( mrl );
+            RecentsMRL::getInstance( p_intf )->addRecent( mrl );
+        }
     }
 }
 
@@ -787,7 +862,79 @@
  **/
 void DialogsProvider::playMRL( const QString &mrl )
 {
-    playlist_Add( THEPL, qtu(mrl), NULL,
-                  PLAYLIST_APPEND | PLAYLIST_GO , PLAYLIST_END, true, false );
-    RecentsMRL::getInstance( p_intf )->addRecent( mrl );
+    p2p_uri_id_type_t p2p_uri_type;
+    p2p_uri_type = p2p_GetIdTypeWithOptString( qtu(mrl), NULL );
+    if( p2p_uri_type != P2P_TYPE_UNSUPPORT ) {
+        p2p_LoadWithOptString( THEP2P, qtu(mrl), NULL, p2p_uri_type, p2p_LoadAsync, NULL, 
+                    PLAYLIST_APPEND, p2p_LoadAddInput, NULL, 
+                    true, true, P2P_DEV, P2P_AFF, P2P_ZONE, pl_Unlocked );
+        QString recent_url = ( p2p_uri_type == P2P_TYPE_PLAYER && mrl.indexOf("acestream://") ==-1 ) ? "acestream://" + mrl : mrl;
+        RecentsMRL::getInstance( p_intf )->addRecent( recent_url );
+    }
+    else {
+        playlist_Add( THEPL, qtu(mrl), NULL,
+                    PLAYLIST_APPEND | PLAYLIST_GO , PLAYLIST_END, true, false );
+        RecentsMRL::getInstance( p_intf )->addRecent( mrl );
+    }
 }
+
+void DialogsProvider::p2p_SaveDialog( input_item_t *p_item )
+{
+    if( !p_item )
+        return;
+    if( !input_item_IsP2P(p_item) )
+        return;
+    p2p_save_format_t save_format = input_item_GetP2PSaveFormat( p_item );
+    if( save_format == P2P_SAVE_UNSAVEABLE )
+        return;
+
+    char *_name = input_item_GetP2PFileName( p_item );
+    QString default_name = _name ? QString( _name ) : "";
+    free( _name );
+    QString default_dir = p_intf->p_sys->filepath;
+    QString filter = "";
+    if( save_format == P2P_SAVE_PLAIN )
+		filter = "All files|*.*";
+	else if( save_format == P2P_SAVE_ENCRYPTED )
+		filter = "ACEMedia files|*.acemedia";
+
+    if( default_name != "" ) {
+		QFileInfo fi( default_name );
+		QString extension = fi.suffix();
+		if( extension != "" ) {
+			if( save_format == P2P_SAVE_PLAIN )
+				filter = extension.toUpper()+" files|*."+extension+"|All files|*.*";
+			else if( save_format == P2P_SAVE_ENCRYPTED ) {
+				filter = "ACEMedia files|*.acemedia|All files|*.*";
+				default_name.replace(default_name.lastIndexOf(extension), extension.size(), "acemedia");
+			}
+		}
+		default_dir += "/" + default_name;
+	}
+    
+    intf_dialog_args_t *p_arg = (intf_dialog_args_t*)calloc( 1, sizeof( intf_dialog_args_t ) );
+    p_arg->psz_title = NULL;
+    p_arg->psz_extensions = strdup( qtu( filter ) );
+    p_arg->psz_default_path = strdup( qtu( default_dir ) );
+    p_arg->b_save = true;
+    p_arg->p_arg = p_item;
+    p_arg->pf_callback = p2p_Save_DialogCallback;
+    emit saveP2P( p_arg );
+}
+
+void DialogsProvider::p2p_Save_DialogCallback( intf_dialog_args_t *p_arg )
+{
+    input_item_t *p_item = (input_item_t *)p_arg->p_arg;
+
+    if( p_item ) {
+        if( p_arg->i_results && p_arg->psz_results[0] ) {
+        
+            char *psz_infohash = input_item_GetP2PInfohash( p_item );
+            if( psz_infohash ) {
+                int index = input_item_GetP2PIndex( p_item );
+                p2p_Save( p2p_Get( DialogsProvider::getInstance()->p_intf ), psz_infohash, index, p_arg->psz_results[0] );
+                free( psz_infohash );
+            }
+        }
+    }
+}
diff -ru vlc-2.1.2.orig/modules/gui/qt4/dialogs_provider.hpp vlc-2.1.2/modules/gui/qt4/dialogs_provider.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/dialogs_provider.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/dialogs_provider.hpp	2014-01-17 15:48:24.774989363 +0200
@@ -42,6 +42,8 @@
 #define TITLE_EXTENSIONS_AUDIO qtr( "Audio Files" )
 #define TITLE_EXTENSIONS_PLAYLIST qtr( "Playlist Files" )
 #define TITLE_EXTENSIONS_SUBTITLE qtr( "Subtitle Files" )
+#define TITLE_EXTENSIONS_P2P qtr( "P2P files" )
+#define TITLE_EXTENSIONS_P2P_AND_MEDIA qtr( "P2P and Media files" )
 #define TITLE_EXTENSIONS_ALL qtr( "All Files" )
 #define EXTENSIONS_ALL "*"
 #define ADD_EXT_FILTER( string, type ) \
@@ -55,6 +57,8 @@
     EXT_FILTER_AUDIO     =  0x04,
     EXT_FILTER_PLAYLIST  =  0x08,
     EXT_FILTER_SUBTITLE  =  0x10,
+    EXT_FILTER_P2P = 0x20,
+    EXT_FILTER_P2P_AND_MEDIA = 0x40,
 };
 
 class QEvent;
@@ -89,11 +93,14 @@
     }
 
     QStringList showSimpleOpen( const QString& help = QString(),
-                                int filters = EXT_FILTER_MEDIA |
+                                int filters = EXT_FILTER_P2P_AND_MEDIA | EXT_FILTER_P2P | EXT_FILTER_MEDIA |
                                 EXT_FILTER_VIDEO | EXT_FILTER_AUDIO |
                                 EXT_FILTER_PLAYLIST,
                                 const QString& path = QString() );
     bool isDying() { return b_isDying; }
+    
+    void p2p_SaveDialog( input_item_t* );
+
 protected:
     QSignalMapper *menusMapper;
     QSignalMapper *menusUpdateMapper;
@@ -112,6 +119,8 @@
     void openDialog( int );
     void addFromSimple( bool, bool );
 
+    static void p2p_Save_DialogCallback( intf_dialog_args_t * );
+
 public slots:
     void playMRL( const QString & );
 
@@ -119,8 +128,10 @@
     void bookmarksDialog();
     void mediaInfoDialog();
     void mediaCodecDialog();
+    void mediaP2PInfoDialog();
     void prefsDialog();
     void extendedDialog();
+    void userDataDialog();
     void synchroDialog();
     void messagesDialog();
 #ifdef ENABLE_VLM
@@ -149,6 +160,7 @@
     void openUrlDialog();
     void openNetDialog();
     void openCaptureDialog();
+    void openCidDialog();
 
     void PLAppendDialog( int tab = OPEN_FILE_TAB );
     void MLAppendDialog( int tab = OPEN_FILE_TAB );
@@ -174,6 +186,7 @@
     void SDMenuAction( const QString& );
 signals:
     void  toolBarConfUpdated();
+    void saveP2P( intf_dialog_args_t* );
 };
 
 class DialogEvent : public QEvent
diff -ru vlc-2.1.4.orig/modules/gui/qt4/input_manager.cpp vlc-2.1.4/modules/gui/qt4/input_manager.cpp
--- vlc-2.1.4.orig/modules/gui/qt4/input_manager.cpp	2014-02-21 15:59:56.000000000 +0200
+++ vlc-2.1.4/modules/gui/qt4/input_manager.cpp	2014-04-29 14:56:45.163148868 +0300
@@ -40,6 +40,7 @@
 #include <QFile>
 #include <QDir>
 #include <QSignalMapper>
+#include <QTime>
 
 #include <assert.h>
 
@@ -54,11 +55,25 @@
 static int PLItemRemoved( vlc_object_t *, const char *,
                         vlc_value_t, vlc_value_t, void * );
 
+
+
+
 static int InputEvent( vlc_object_t *, const char *,
                        vlc_value_t, vlc_value_t, void * );
 static int VbiEvent( vlc_object_t *, const char *,
                      vlc_value_t, vlc_value_t, void * );
 
+static int P2PSaveableChanged( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+static int NothingToPlay( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+static int P2PShowQualitiesOnNextAppend( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+static int P2PInfoChanged( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+static int P2PStatusChanged( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+static int P2PErrorChanged( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+static int P2PAdParamsChanged( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+static int P2PLoadUrl( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+static int PLIndexChanged( vlc_object_t *, const char *, vlc_value_t, vlc_value_t, void * );
+
+                     
 /* Ensure arbitratry (not dynamically allocated) event IDs are not in use */
 static inline void registerAndCheckEventIds( int start, int end )
 {
@@ -76,7 +91,7 @@
 InputManager::InputManager( QObject *parent, intf_thread_t *_p_intf) :
                            QObject( parent ), p_intf( _p_intf )
 {
-    i_old_playing_status = END_S;
+    i_old_playing_status = INIT_S;
     oldName      = "";
     artUrl       = "";
     p_input      = NULL;
@@ -87,6 +102,12 @@
     timeA        = 0;
     timeB        = 0;
     f_cache      = -1.; /* impossible initial value, different from all */
+
+    m_cached_volume = -1.f;
+    m_is_ad = false;
+    m_ad_params.reset();
+    m_first_time_pos_changed = true;
+
     registerAndCheckEventIds( IMEvent::PositionUpdate, IMEvent::FullscreenControlPlanHide );
     registerAndCheckEventIds( PLEvent::PLItemAppended, PLEvent::PLEmpty );
 }
@@ -117,12 +138,33 @@
 
         p_item = input_GetItem( p_input );
         emit rateChanged( var_GetFloat( p_input, "rate" ) );
+
+        m_first_time_pos_changed = true;
+        if( p_item ) {
+            bool isP2P = input_item_IsP2P( p_item );
+            emit disableSeekOnSliderDrag( isP2P );
+            bool b = input_item_GetP2PIsLiveFlag( p_item );
+            emit enableLiveStreamButton(b);
+            emit enableSliderLiveStreamMode(b);
+            checkQualityList( p_item );
+            emit enableSaveButton( input_item_GetP2PSaveFormat( p_item ) != P2P_SAVE_UNSAVEABLE );
+
+            m_is_ad = isAd();
+
+            if(isP2P)
+                emit inputIsAdvertisement( input_item_GetP2PIsAdFlag(p_item) );
+            else {
+                emit inputIsAdvertisement(false);
+                m_ad_params.reset();
+            }
+        }
     }
     else
     {
         p_item = NULL;
         assert( !p_input_vbi );
         emit rateChanged( var_InheritFloat( p_intf, "rate" ) );
+        emit inputIsAdvertisement(false);
     }
 }
 
@@ -153,6 +195,11 @@
     vlc_object_release( p_input );
     p_input = NULL;
 
+    emit inputIsAdvertisement(false);
+    m_first_time_pos_changed = true;
+    emit notifyStateChanged(AceWebBrowser::BHPS_STOPPED, m_is_ad);
+    emit enableSliderLiveStreamMode(false);
+
     emit positionUpdated( -1.0, 0 ,0 );
     emit rateChanged( var_InheritFloat( p_intf, "rate" ) );
     emit nameChanged( "" );
@@ -185,6 +232,8 @@
 
     if( i_type == IMEvent::ItemChanged )
         UpdateMeta( ple->item() );
+    if( i_type == IMEvent::PLIndexChanged)
+        emit notifyStateChanged(AceWebBrowser::BHPS_NONE, isAd());
 
     if( !hasInput() )
         return;
@@ -261,22 +310,70 @@
     case IMEvent::EPGEvent:
         UpdateEPG();
         break;
+    case IMEvent::P2PUpdateSaveableCmd:
+        UpdateSaveable();
+        break;
+    case IMEvent::P2PLivePos:
+        UpdateLivePos();
+        break;
     default:
         msg_Warn( p_intf, "This shouldn't happen: %i", i_type );
         assert(0);
     }
 }
 
+void InputManager::setAdParams(QString url, QString text, int skipoffset, QString disurl, bool is_percent)
+{
+    m_ad_params.reset();
+    m_ad_params.url = url;
+    m_ad_params.visit_text = text;
+    m_ad_params.unableads_url = disurl;
+    m_ad_params.skip_offset = skipoffset;
+    m_ad_params.is_percent_offset = is_percent;
+    m_ad_params.enable_skip = false;
+    emit setVisitAdButtonText(text);
+
+    if(isAd()) {
+        firstAdPosProcess();
+    }
+}
+
+
+void InputManager::dropCachedVolume()
+{
+    if(m_cached_volume > 0.f) {
+        m_cached_volume = -1.f;
+    }
+}
+
+void InputManager::skipAd()
+{
+    if( isAd() ) {
+        char *url = input_item_GetURI( p_item );
+        if(url) {
+            input_item_UnblockP2PIsAdFlag( p_item );
+            delInput();
+            p2p_Skip( THEP2P, url );
+            free(url);
+            //
+            //if( hasInput() )
+            //    var_SetFloat( p_input, "position", 1.0 );
+        }
+    }
+}
+
 /* Add the callbacks on Input. Self explanatory */
 inline void InputManager::addCallbacks()
 {
     var_AddCallback( p_input, "intf-event", InputEvent, this );
+    var_AddCallback( THEPL, "playlist-item-update-saveable", P2PSaveableChanged, this );
 }
 
 /* Delete the callbacks on Input. Self explanatory */
 inline void InputManager::delCallbacks()
 {
     var_DelCallback( p_input, "intf-event", InputEvent, this );
+    var_DelCallback( THEPL, "playlist-item-update-saveable", P2PSaveableChanged, this );
 }
 
 /* Static callbacks for IM */
@@ -373,6 +470,10 @@
         /* EPG data changed */
         event = new IMEvent( IMEvent::EPGEvent );
         break;
+        
+    case INPUT_EVENT_P2P_LIVEPOS :
+        event = new IMEvent( IMEvent::P2PLivePos );
+        break;
 
     case INPUT_EVENT_SIGNAL:
         /* This is for capture-card signals */
@@ -398,6 +499,37 @@
     return VLC_SUCCESS;
 }
 
+static int P2PSaveableChanged( vlc_object_t * obj, const char *var, vlc_value_t old, vlc_value_t cur, void *data )
+{
+    VLC_UNUSED( obj ); VLC_UNUSED( var ); VLC_UNUSED( old ); VLC_UNUSED( cur );
+    
+    InputManager *im = (InputManager*)data;
+    IMEvent *event = new IMEvent( IMEvent::P2PUpdateSaveableCmd );
+
+    QApplication::postEvent( im, event );
+    return VLC_SUCCESS;
+}
+
+void InputManager::firstAdPosProcess()
+{
+    if(p_input) {
+        int i_length = var_GetTime(  p_input , "length" ) / CLOCK_FREQ;
+        if(m_ad_params.skip_offset >= 0) {
+            if((m_ad_params.is_percent_offset && m_ad_params.skip_offset > 99) 
+                || (!m_ad_params.is_percent_offset && m_ad_params.skip_offset >= i_length)) {
+                m_ad_params.skip_offset = -1;
+                m_ad_params.enable_skip = false;
+            }
+            else
+                m_ad_params.enable_skip = true;
+        }
+        else
+            m_ad_params.enable_skip = false;
+        emit setDisableAdButtonEnable(m_ad_params.unableads_url != "");
+        emit setVisitAdButtonEnable(m_ad_params.url != "");
+    }
+}
+
 void InputManager::UpdatePosition()
 {
     /* Update position */
@@ -407,7 +539,47 @@
     i_length = var_GetTime(  p_input , "length" ) / CLOCK_FREQ;
     i_time = var_GetTime(  p_input , "time");
     f_pos = var_GetFloat(  p_input , "position" );
+
+    if(m_first_time_pos_changed) {
+        if(isAd()) { 
+            firstAdPosProcess();
+        }
+        else {
+            p2p_RequestLoadUrlAd(THEP2P, P2P_LOAD_URL_WEBSTAT_PLAY, 0);
+        }
+
+        m_first_time_pos_changed = false;
+    }
+
     emit positionUpdated( f_pos, i_time, i_length );
+    
+    if(isAd()) {
+        if(m_ad_params.enable_skip) {
+            if(m_ad_params.is_percent_offset) {
+                if( f_pos * 100 >= m_ad_params.skip_offset ) {
+                    emit setWaitForAd( -1 );
+                    m_ad_params.skip_offset = -1;
+                }
+                else {
+                    int last = m_ad_params.skip_offset - f_pos * 100;
+                    emit setWaitForAd(i_length * last / 100);
+                }
+            }
+            else {
+                if(i_length > 0 && (int)(f_pos * i_length) >= m_ad_params.skip_offset) {
+                    emit setWaitForAd( -1 );
+                    m_ad_params.skip_offset = -1;
+                }
+                else {
+                    int last = m_ad_params.skip_offset - (int)(f_pos * i_length);
+                    emit setWaitForAd( last );
+                }
+            }
+        }
+        else {
+            emit setWaitForAd( i_length - i_length * f_pos );
+        }
+    }
 }
 
 void InputManager::UpdateNavigation()
@@ -444,6 +616,9 @@
     {
         i_old_playing_status = state;
         emit playingStatusChanged( state );
+        if(state != OPENING_S && state != INIT_S) {
+            emit notifyStateChanged(state, isAd());
+        }
     }
 }
 
@@ -502,6 +677,16 @@
     return i_old_playing_status;
 }
 
+bool InputManager::isAd() 
+{
+    return p_item && input_item_IsP2P(p_item) && input_item_GetP2PIsAdFlag(p_item);
+}
+
+bool InputManager::isP2P() 
+{
+    return p_item && input_item_IsP2P(p_item);
+}
+
 bool InputManager::hasAudio()
 {
     if( hasInput() )
@@ -621,6 +806,26 @@
     if( hasInput() )
     {
         /* TODO */
+
+        /* advolume stuff */
+        audio_output_t *aout = input_GetAout( p_input );
+        if( !aout )
+            return;
+        if(isAd()) {
+            float advolume = var_InheritFloat(aout, "advolume");
+            float volume = playlist_VolumeGet(pl_Get(p_intf));
+            if(volume > advolume) {
+                playlist_VolumeSet(pl_Get(p_intf), advolume);
+                m_cached_volume = volume;
+            }
+        }
+        else {
+            if(m_cached_volume > 0.f) {
+                playlist_VolumeSet(pl_Get(p_intf), m_cached_volume );
+                m_cached_volume = -1.f;
+            }
+        }
+        vlc_object_release( aout );
     }
 }
 void InputManager::UpdateCaching()
@@ -761,6 +966,23 @@
     }
 }
 
+void InputManager::UpdateLivePos()
+{
+    if( hasInput() ) {
+        vlc_value_t var;
+        if( var_Get( THEP2P, "livepos", &var ) == VLC_SUCCESS ) {
+            emit updateLiveStreamButton( var.p2p_livepos.is_live );
+            emit updateSliderLiveStreamPos( var.p2p_livepos.live_first, 
+                                            var.p2p_livepos.live_last, 
+                                            var.p2p_livepos.pos, 
+                                            var.p2p_livepos.first_ts, 
+                                            var.p2p_livepos.last_ts, 
+                                            var.p2p_livepos.last, 
+                                            var.p2p_livepos.buffer_pieces );
+        }
+    }
+}
+
 /* User update of the slider */
 void InputManager::sliderUpdate( float new_pos )
 {
@@ -955,6 +1177,69 @@
         var_SetTime( THEMIM->getInput(), "time" , timeA );
 }
 
+void InputManager::UpdateSaveable()
+{
+	if( p_item )
+        emit enableSaveButton( input_item_GetP2PSaveFormat(p_item) != P2P_SAVE_UNSAVEABLE );
+}
+
+void InputManager::liveSeekEvent( int pos )
+{
+    emit liveSeekOccured();
+    p2p_LiveSeek( THEP2P, pos );
+}
+
+void InputManager::checkQualityList( input_item_t *p_i )
+{
+    QStringList q_list;
+    int q_current = -1;
+    if( p_i ) {
+        int q_size = input_item_GetP2PQualitySize( p_i );
+        if( q_size > 0 ) {
+            q_current = input_item_GetP2PQualityCurrent( p_i );
+            for( int i = 0; i<q_size; ++i ) {
+                char *q = input_item_GetP2PQualityValue( p_i, i );
+                QString item(q);
+                q_list.insert( i, item ); 
+                free(q);
+            }
+        }
+    }
+    emit enableQualitiesButton( q_list, q_current );
+}
+
+void InputManager::changeQuality( int quality )
+{
+    if( hasInput() ) {
+        if( p_item ) {
+            input_item_SetP2PQualityCurrent( p_item, quality );
+            playlist_Skip( THEPL,0 );
+        }
+    }
+    else {
+        playlist_item_t *p_pl_cur = playlist_CurrentPlayingItem(THEPL);
+        if( p_pl_cur && p_pl_cur->p_input ) {
+            input_item_SetP2PQualityCurrent( p_pl_cur->p_input, quality );
+            p2p_Stop( THEP2P );
+            playlist_Skip( THEPL,0 );
+        }
+        else {
+            playlist_item_t *p_last_playing_item = playlist_LastPlayingItem(THEPL);
+            if( p_last_playing_item && p_last_playing_item->p_input ) {
+                input_item_SetP2PQualityCurrent( p_last_playing_item->p_input, quality );
+                playlist_Play(THEPL);
+            }
+            else {
+                input_item_t *p_item = playlist_GetFirstP2PIntupItem(THEPL);
+                if( p_item ) {
+                    input_item_SetP2PQualityCurrent( p_item, quality );
+                    playlist_Play(THEPL);
+                }
+            }
+        }
+    }
+}
+
 /**********************************************************************
  * MainInputManager implementation. Wrap an input manager and
  * take care of updating the main playlist input.
@@ -962,7 +1247,7 @@
  **********************************************************************/
 
 MainInputManager::MainInputManager( intf_thread_t *_p_intf )
-    : QObject(NULL), p_intf( _p_intf ),
+    : QObject(NULL), p_intf( _p_intf ), b_show_qualities_button_on_append(false),
       random( VLC_OBJECT(THEPL), "random" ),
       repeat( VLC_OBJECT(THEPL), "repeat" ), loop( VLC_OBJECT(THEPL), "loop" ),
       volume( VLC_OBJECT(THEPL), "volume" ), mute( VLC_OBJECT(THEPL), "mute" )
@@ -970,6 +1255,9 @@
     p_input = NULL;
     im = new InputManager( this, p_intf );
 
+    CONNECT(this, setAdParams(QString, QString, int, QString, bool), 
+            im, setAdParams(QString, QString, int, QString, bool));
+
     var_AddCallback( THEPL, "item-change", ItemChanged, im );
     var_AddCallback( THEPL, "activity", PLItemChanged, this );
     var_AddCallback( THEPL, "leaf-to-parent", LeafToParent, this );
@@ -982,6 +1270,15 @@
     volume.addCallback( this, SLOT(notifyVolume(float)) );
     mute.addCallback( this, SLOT(notifyMute(bool)) );
 
+    var_AddCallback( THEPL, "playlist-nothing-to-play", NothingToPlay, this );
+    var_AddCallback( THEPL, "playlist-item-show-appended-qualities", P2PShowQualitiesOnNextAppend, this );
+    var_AddCallback( THEP2P, "info", P2PInfoChanged, this );
+    var_AddCallback( THEP2P, "status", P2PStatusChanged, this );
+    var_AddCallback( THEP2P, "error", P2PErrorChanged, this );
+    var_AddCallback( THEP2P, "adparams", P2PAdParamsChanged, this );
+    var_AddCallback( THEP2P, "load-url", P2PLoadUrl, this );
+    var_AddCallback( THEPL, "playlist-index-changed", PLIndexChanged, im);
+
     /* Warn our embedded IM about input changes */
     DCONNECT( this, inputChanged( input_thread_t * ),
               im, setInput( input_thread_t * ) );
@@ -1011,6 +1308,14 @@
     var_DelCallback( THEPL, "playlist-item-append", PLItemAppended, this );
     var_DelCallback( THEPL, "playlist-item-deleted", PLItemRemoved, this );
 
+    var_DelCallback( THEPL, "playlist-nothing-to-play", NothingToPlay, this );
+    var_DelCallback( THEPL, "playlist-item-show-appended-qualities", P2PShowQualitiesOnNextAppend, this );
+    var_DelCallback( THEP2P, "info", P2PInfoChanged, this );
+    var_DelCallback( THEP2P, "status", P2PStatusChanged, this );
+    var_DelCallback( THEP2P, "error", P2PErrorChanged, this );
+    var_DelCallback( THEP2P, "adparams", P2PAdParamsChanged, this );
+    var_DelCallback( THEPL, "playlist-index-changed", PLIndexChanged, im);
+    var_DelCallback( THEP2P, "load-url", P2PLoadUrl, this );
     delete menusAudioMapper;
 }
 
@@ -1035,7 +1340,8 @@
     {
     case PLEvent::PLItemAppended:
         plEv = static_cast<PLEvent*>( event );
-        emit playlistItemAppended( plEv->getItemId(), plEv->getParentId() );
+        //emit playlistItemAppended( plEv->getItemId(), plEv->getParentId() );
+        processAppendItem( plEv->getItemId(), plEv->getParentId() );
         return;
     case PLEvent::PLItemRemoved:
         plEv = static_cast<PLEvent*>( event );
@@ -1049,6 +1355,37 @@
         plEv = static_cast<PLEvent*>( event );
         emit leafBecameParent( plEv->getItemId() );
         return;
+    case IMEvent::P2PShowQualitiesOnAppendCmd:
+        b_show_qualities_button_on_append = true;
+        return;
+    case IMEvent::P2PUpdateInfo:
+        updateInfo();
+        return;
+    case IMEvent::P2PUpdateStatus :
+        updateStatus();
+        return;
+    case IMEvent::P2PUpdateError :
+        updateError();
+        return;
+    case IMEvent::NothingToPlayCmd :
+        emit nothingToPlay();
+        return;
+    case OtherAdParamsUpdate_Type: {
+        AdParamsEvent *adp = static_cast<AdParamsEvent*>(event);
+        emit setAdParams(adp->url, adp->text, adp->skipoffset, adp->noadurl, adp->is_percent);
+        return;
+    }
+    case OtherLoadUrl_Type: {
+        LoadUrlEvent *ev = static_cast<LoadUrlEvent*>(event);
+        emit loadUrlEvent(ev->item);
+        return;
+    }
+    case OtherClearLoadUrl_Type: {
+        ClearLoadUrlEvent *ev = static_cast<ClearLoadUrlEvent*>(event);
+        if(!getIM()->isAd())
+            emit clearLoadUrlEvent(ev->type);
+        return;
+    }
     default:
         if( type != IMEvent::ItemChanged ) return;
     }
@@ -1062,7 +1399,13 @@
 /* Playlist Control functions */
 void MainInputManager::stop()
 {
-   playlist_Stop( THEPL );
+    if(p_input) {
+        int state = var_GetInteger( p_input, "state" );
+        if(state == PLAYING_S || state == PAUSE_S) {
+            emit userStopAction();
+        }
+    }
+    playlist_Stop( THEPL );
 }
 
 void MainInputManager::next()
@@ -1088,8 +1431,13 @@
     /* No input, play */
     if( !p_input )
         playlist_Play( THEPL );
-    else
+    else {
+        int state = var_GetInteger( p_input, "state" );
         playlist_Pause( THEPL );
+        if(state == PLAYING_S) {
+            emit userPauseAction();
+        }
+    }
 }
 
 void MainInputManager::play()
@@ -1178,6 +1526,51 @@
     return b_empty;
 }
 
+void MainInputManager::processAppendItem( int id, int parent )
+{
+    emit playlistItemAppended( id, parent );
+    if( b_show_qualities_button_on_append ) {
+        b_show_qualities_button_on_append = false;
+        playlist_item_t *p = playlist_ItemGetById( THEPL, id );
+        if( p && p->p_input ) {
+            getIM()->checkQualityList( p->p_input );
+        }
+    }
+}
+
+void MainInputManager::updateInfo()
+{
+    QString ret = "";
+    char *psz_info = var_GetString( THEP2P, "info" );
+    if( psz_info ) {
+        ret.sprintf( "%s", psz_info );
+        free( psz_info );
+        emit p2pInfoChanged(ret);
+    }
+}
+
+void MainInputManager::updateStatus()
+{
+    QString ret = "";
+    char *psz_status = var_GetString( THEP2P, "status" );
+    if( psz_status ) {
+        ret.sprintf( "%s", psz_status );
+        free( psz_status );
+        emit p2pStatusChanged(ret);
+    }
+}
+
+void MainInputManager::updateError()
+{
+    QString ret = "";
+    char *psz_err = var_GetString( THEP2P, "error" );
+    if( psz_err ) {
+        ret.sprintf( "%s", psz_err );
+        free( psz_err );
+        emit p2pErrorChanged(ret);
+    }
+}
+
 /****************************
  * Static callbacks for MIM *
  ****************************/
@@ -1201,7 +1594,6 @@
     MainInputManager *mim = (MainInputManager*)param;
 
     PLEvent *event = new PLEvent( PLEvent::LeafToParent, newval.i_int );
-
     QApplication::postEvent( mim, event );
     return VLC_SUCCESS;
 }
@@ -1216,7 +1608,6 @@
     emit soundMuteChanged(mute);
 }
 
-
 void MainInputManager::menusUpdateAudio( const QString& data )
 {
     audio_output_t *aout = getAout();
@@ -1259,3 +1650,172 @@
     }
     return VLC_SUCCESS;
 }
+
+static int NothingToPlay( vlc_object_t * obj, const char *var, vlc_value_t old, vlc_value_t cur, void *data )
+{
+    VLC_UNUSED( obj ); VLC_UNUSED( var ); VLC_UNUSED( old ); VLC_UNUSED( cur );
+    
+    MainInputManager *mim = static_cast<MainInputManager*>(data);
+
+    IMEvent *event = new IMEvent( IMEvent::NothingToPlayCmd );
+    QApplication::postEvent( mim, event );
+    return VLC_SUCCESS;
+}
+
+static int P2PShowQualitiesOnNextAppend( vlc_object_t * obj, const char *var, vlc_value_t old, vlc_value_t cur, void *data )
+{
+    VLC_UNUSED( obj ); VLC_UNUSED( var ); VLC_UNUSED( old ); VLC_UNUSED( cur );
+    
+    MainInputManager *mim = static_cast<MainInputManager*>(data);
+
+    IMEvent *event = new IMEvent( IMEvent::P2PShowQualitiesOnAppendCmd );
+    QApplication::postEvent( mim, event );
+    return VLC_SUCCESS;
+}
+
+static int P2PInfoChanged( vlc_object_t * obj, const char *var, vlc_value_t old, vlc_value_t cur, void *data )
+{
+    VLC_UNUSED( obj ); VLC_UNUSED( var ); VLC_UNUSED( old ); VLC_UNUSED( cur );
+    
+    MainInputManager *mim = static_cast<MainInputManager*>(data);
+
+    IMEvent *event = new IMEvent( IMEvent::P2PUpdateInfo );
+    QApplication::postEvent( mim, event );
+    return VLC_SUCCESS;
+}
+
+static int P2PStatusChanged( vlc_object_t * obj, const char *var, vlc_value_t old, vlc_value_t cur, void *data )
+{
+    VLC_UNUSED( obj ); VLC_UNUSED( var ); VLC_UNUSED( old ); VLC_UNUSED( cur );
+
+    MainInputManager *mim = static_cast<MainInputManager*>(data);
+
+    IMEvent *event = new IMEvent( IMEvent::P2PUpdateStatus );
+    QApplication::postEvent( mim, event );
+    return VLC_SUCCESS;
+}
+
+static int P2PErrorChanged( vlc_object_t * obj, const char *var, vlc_value_t old, vlc_value_t cur, void *data )
+{
+    VLC_UNUSED( obj ); VLC_UNUSED( var ); VLC_UNUSED( old ); VLC_UNUSED( cur );
+
+    MainInputManager *mim = static_cast<MainInputManager*>(data);
+
+    IMEvent *event = new IMEvent( IMEvent::P2PUpdateError );
+    QApplication::postEvent( mim, event );
+    return VLC_SUCCESS;
+}
+
+static int P2PLoadUrl( vlc_object_t * obj, const char *var, vlc_value_t old, vlc_value_t cur, void *data )
+{
+    VLC_UNUSED( obj ); VLC_UNUSED( var ); VLC_UNUSED( old );
+
+    MainInputManager *mim = static_cast<MainInputManager*>(data);
+    if(cur.p_address) {
+        p2p_load_url_item_t *p_loadurl = (p2p_load_url_item_t *)cur.p_address;
+        if( p_loadurl ) {
+            AceWebBrowser::BrowserType _type = (p_loadurl->type == P2P_LOAD_URL_WEBSTAT_PLAY
+                || p_loadurl->type == P2P_LOAD_URL_WEBSTAT_PAUSE
+                || p_loadurl->type == P2P_LOAD_URL_WEBSTAT_STOP
+                || p_loadurl->type == P2P_LOAD_URL_WEBSTAT_FULLSCREEN)
+                ? AceWebBrowser::BTYPE_WEBSTAT
+                : static_cast<AceWebBrowser::BrowserType>(p_loadurl->type);
+            if(p_loadurl->clear) {
+                ClearLoadUrlEvent *event = new ClearLoadUrlEvent(_type);
+                QApplication::postEvent( mim, event );
+                return VLC_SUCCESS;
+            }
+            
+            AceWebBrowser::LoadItem *item = new AceWebBrowser::LoadItem(
+                    _type,
+                    AceWebBrowser::UrlWithId(
+                            QString(p_loadurl->url).split(", "),
+                            QString(p_loadurl->id).split(", ")),
+                    p_loadurl->width,
+                    p_loadurl->height,
+                    p_loadurl->left,
+                    p_loadurl->top,
+                    p_loadurl->right,
+                    p_loadurl->bottom,
+                    p_loadurl->allow_dialogs,
+                    p_loadurl->enable_flash,
+                    static_cast<AceWebBrowser::BrowserCookies>(p_loadurl->cookies),
+                    QString(p_loadurl->embed_scripts).split(", "),
+                    QString(p_loadurl->embed_code),
+                    p_loadurl->preload,
+                    QString(p_loadurl->content_type),
+                    QString(p_loadurl->creative_type),
+                    QString(p_loadurl->click_url),
+                    static_cast<AceWebBrowser::BrowserUserAgent>(p_loadurl->user_agent),
+                    p_loadurl->close_after_seconds,
+                    p_loadurl->show_time,
+                    p_loadurl->start_hidden,
+                    p_loadurl->allow_window_open,
+                    p_loadurl->group_id,
+                    p_loadurl->url_filter,
+                    p_loadurl->useIE
+                    );
+
+            LoadUrlEvent *event = new LoadUrlEvent(*item);
+            QApplication::postEvent( mim, event );
+        }
+    }
+    
+    return VLC_SUCCESS;
+}
+
+static int P2PAdParamsChanged( vlc_object_t * obj, const char *var, vlc_value_t old, vlc_value_t cur, void *data )
+{
+    VLC_UNUSED( obj ); VLC_UNUSED( var ); VLC_UNUSED( old );
+    MainInputManager *mim = static_cast<MainInputManager*>(data);
+    p2p_ad_params_t *p_ad_params = (p2p_ad_params_t *)cur.p_address;
+    
+    if( p_ad_params ) {
+        QString url = "";
+        QString text = "";
+        QString skipoff = "";
+        int skipoffset = -1;
+        bool is_percent = false;
+        QString noadurl = "";
+        
+        if( p_ad_params->url )
+            url.sprintf( "%s", p_ad_params->url );
+        if( p_ad_params->text )
+            text.sprintf( "%s", p_ad_params->text );
+        if( p_ad_params->skipoffset )
+            skipoff.sprintf( "%s", p_ad_params->skipoffset );
+        if( p_ad_params->noadsurl )
+            noadurl.sprintf( "%s", p_ad_params->noadsurl );
+        
+        if(skipoff == "") {
+            skipoffset = -1;
+            is_percent = false;
+        }
+        else {
+            if(skipoff.at(skipoff.length()-1) == '%') {
+                is_percent = true;
+                skipoff.resize(skipoff.length()-1);
+                skipoffset = skipoff.toInt();
+            }
+            else {
+                is_percent = false;
+                QTime tm = QTime::fromString(skipoff, "hh:mm:ss");
+                skipoffset = tm.hour() * 60 * 60 + tm.minute() * 60 + tm.second();
+            }
+        }
+        AdParamsEvent *event = new AdParamsEvent( OtherAdParamsUpdate_Type, url, text, skipoffset, noadurl, is_percent );
+        QApplication::postEvent( mim, event );
+    }
+    return VLC_SUCCESS;
+}
+
+static int PLIndexChanged( vlc_object_t *p_this, const char *psz_var,
+                        vlc_value_t oldval, vlc_value_t, void *param )
+{
+    VLC_UNUSED( p_this ); VLC_UNUSED( psz_var ); VLC_UNUSED( oldval );
+    InputManager *im = (InputManager*)param;
+
+    IMEvent *event = new IMEvent( IMEvent::PLIndexChanged );
+    QApplication::postEvent( im, event );
+    return VLC_SUCCESS;
+}
diff -ru vlc-2.1.4.orig/modules/gui/qt4/input_manager.hpp vlc-2.1.4/modules/gui/qt4/input_manager.hpp
--- vlc-2.1.4.orig/modules/gui/qt4/input_manager.hpp	2014-02-21 15:59:56.000000000 +0200
+++ vlc-2.1.4/modules/gui/qt4/input_manager.hpp	2014-04-11 13:08:13.750100524 +0300
@@ -37,8 +37,13 @@
 
 #include <QObject>
 #include <QEvent>
+#include <QStringList>
+
+#include "acewebbrowser/loaditem.hpp"
+
 class QSignalMapper;
 
+
 enum { NORMAL,    /* loop: 0, repeat: 0 */
        REPEAT_ONE,/* loop: 0, repeat: 1 */
        REPEAT_ALL,/* loop: 1, repeat: 0 */
@@ -69,9 +74,18 @@
         RandomChanged,
         LoopOrRepeatChanged,
         EPGEvent,
+        P2PUpdateSaveableCmd,
+        P2PLivePos,
+        P2PShowQualitiesOnAppendCmd,
+        P2PUpdateInfo,
+        P2PUpdateStatus,
+        P2PUpdateError,
+        NothingToPlayCmd,
+        PLIndexChanged,
+        
     /*    SignalChanged, */
 
-        FullscreenControlToggle = QEvent::User + IMEventTypeOffset + 20,
+        FullscreenControlToggle = QEvent::User + IMEventTypeOffset + 50,
         FullscreenControlShow,
         FullscreenControlHide,
         FullscreenControlPlanHide,
@@ -120,11 +134,68 @@
     int i_parent;
 };
 
+enum OtherEventsTypes
+{
+    OtherAdParamsUpdate_Type = QEvent::User + OtherEventTypeOffset + 1,
+    OtherLoadUrl_Type,
+    OtherClearLoadUrl_Type,
+};
+
+class LoadUrlEvent : public QEvent
+{
+public:
+    LoadUrlEvent(AceWebBrowser::LoadItem _item)
+        : QEvent((QEvent::Type)(OtherLoadUrl_Type)), item(_item) {}
+
+    AceWebBrowser::LoadItem item;
+};
+
+class ClearLoadUrlEvent : public QEvent
+{
+public:
+    ClearLoadUrlEvent(AceWebBrowser::BrowserType _type)
+        : QEvent((QEvent::Type)(OtherClearLoadUrl_Type)), type(_type) {}
+
+    AceWebBrowser::BrowserType type;
+};
+
+class AdParamsEvent : public QEvent
+{
+public:
+    AdParamsEvent( int t, QString a, QString b, int c, QString d, bool e )
+        : QEvent( (QEvent::Type)(t) ), url(a), text(b), skipoffset(c), noadurl(d), is_percent(e) {}
+
+
+    QString url;
+    QString text;
+    int skipoffset;
+    QString noadurl;
+    bool is_percent;
+};
+
 class InputManager : public QObject
 {
     Q_OBJECT
     friend class MainInputManager;
 
+    struct AdParams {
+        void reset() {
+            url = "";
+            visit_text = "";
+            unableads_url = "";
+            skip_offset = -1;
+            is_percent_offset = 0;
+            enable_skip = false;
+        }
+
+        QString url;
+        QString visit_text;
+        QString unableads_url;
+        int skip_offset;
+        bool is_percent_offset;
+        bool enable_skip;
+    };
+
 public:
     InputManager( QObject *, intf_thread_t * );
     virtual ~InputManager();
@@ -138,6 +209,8 @@
     }
 
     int playingStatus();
+    bool isAd();
+    bool isP2P();
     bool hasAudio();
     bool hasVideo() { return hasInput() && b_video; }
     bool hasVisualisation();
@@ -147,6 +220,10 @@
     QString getName() { return oldName; }
     static const QString decodeArtURL( input_item_t *p_item );
 
+    void checkQualityList( input_item_t* );
+    QString getVisitUrl() { return m_ad_params.url; }
+    QString getDisableUrl() { return m_ad_params.unableads_url; }
+
 private:
     intf_thread_t  *p_intf;
     input_thread_t *p_input;
@@ -160,6 +237,11 @@
     bool            b_video;
     mtime_t         timeA, timeB;
 
+    float m_cached_volume;
+    AdParams m_ad_params;
+    bool m_is_ad;
+    bool m_first_time_pos_changed;
+    
     void customEvent( QEvent * );
 
     void addCallbacks();
@@ -182,6 +264,9 @@
     void UpdateRecord();
     void UpdateProgramEvent();
     void UpdateEPG();
+    
+    void UpdateLivePos();
+    void firstAdPosProcess();
 
 public slots:
     void setInput( input_thread_t * ); ///< Our controlled input changed
@@ -208,6 +293,14 @@
     /* A to B Loop */
     void setAtoB();
 
+    void liveSeekEvent( int );
+    void changeQuality( int );
+    void UpdateSaveable();
+    void setAdParams(QString, QString, int, QString, bool);
+    void skipAd();
+    
+    void dropCachedVolume();
+
 private slots:
     void AtoBLoop( float, int64_t, int );
 
@@ -248,6 +341,23 @@
     /// Program Event changes
     void encryptionChanged( bool );
     void epgChanged();
+    
+    void disableSeekOnSliderDrag( bool );
+    void enableSliderLiveStreamMode( bool );
+    void enableLiveStreamButton( bool );
+    void updateLiveStreamButton( bool );
+    void updateSliderLiveStreamPos( int, int, int, int, int, int, int ); // update slider
+    void liveSeekOccured();
+    void enableQualitiesButton( QStringList, int );
+    void enableSaveButton(bool);
+
+    void inputIsAdvertisement(bool);
+    void setDisableAdButtonEnable(bool);
+    void setVisitAdButtonEnable(bool);
+    void setVisitAdButtonText(QString);
+    void setWaitForAd(int);
+    
+    void notifyStateChanged(int, bool);
 };
 
 class MainInputManager : public QObject, public Singleton<MainInputManager>
@@ -287,7 +397,13 @@
     QVLCBool random, repeat, loop;
     QVLCFloat volume;
     QVLCBool mute;
-
+    
+    bool b_show_qualities_button_on_append;
+    void updateInfo();
+    void updateStatus();
+    void updateError();
+    void processAppendItem( int, int );
+    
 public slots:
     void togglePlayPause();
     void play();
@@ -318,6 +434,18 @@
     void randomChanged( bool );
     void repeatLoopChanged( int );
     void leafBecameParent( int );
+
+    void setAdParams(QString,QString,int,QString,bool);
+    void p2pInfoChanged( const QString& );
+    void p2pStatusChanged( const QString& );
+    void p2pErrorChanged( const QString& );
+    void nothingToPlay();
+    
+    void loadUrlEvent(const AceWebBrowser::LoadItem &item);
+    void clearLoadUrlEvent(AceWebBrowser::BrowserType type);
+    
+    void userPauseAction();
+    void userStopAction();
 };
 
 #endif
diff -ru vlc-2.1.4.orig/modules/gui/qt4/main_interface.cpp vlc-2.1.4/modules/gui/qt4/main_interface.cpp
--- vlc-2.1.4.orig/modules/gui/qt4/main_interface.cpp	2014-02-21 15:59:56.000000000 +0200
+++ vlc-2.1.4/modules/gui/qt4/main_interface.cpp	2014-05-13 15:19:51.000000000 +0300
@@ -41,12 +41,20 @@
 #include "components/playlist/playlist.hpp"     // plWidget
 #include "dialogs/firstrun.hpp"                 // First Run
 #include "dialogs/playlist.hpp"                 // PlaylistDialog
+#include "dialogs/userinfo.hpp"
+#include "dialogs/mininginfo.hpp"
+
+#include "acewebbrowser/browser.hpp"
+#include "acewebbrowser/javascriptobject.hpp"
+#include "acewebbrowser/iejsobject.hpp"
+#include "acewebbrowser/exceptions.hpp"
 
 #include "menus.hpp"                            // Menu creation
 #include "recents.hpp"                          // RecentItems when DnD
 
 #include <QCloseEvent>
 #include <QKeyEvent>
+#include <QResizeEvent>
 
 #include <QUrl>
 #include <QSize>
@@ -59,9 +67,12 @@
 #include <QLabel>
 #include <QStackedWidget>
 #include <QFileInfo>
+#include <QDesktopServices>
+#include <QTimer>
 
 #include <vlc_keys.h>                       /* Wheel event */
 #include <vlc_vout_display.h>               /* vout_thread_t and VOUT_ events */
+#include <vlc_dialog.h>
 
 // #define DEBUG_INTF
 
@@ -75,6 +86,15 @@
 static int IntfRaiseMainCB( vlc_object_t *p_this, const char *psz_variable,
                            vlc_value_t old_val, vlc_value_t new_val,
                            void *param );
+static int IntfShowUserDataCB( vlc_object_t *p_this, const char *psz_variable,
+                           vlc_value_t old_val, vlc_value_t new_val,
+                           void *param );
+static int IntfShowErrorDialogCB( vlc_object_t *p_this, const char *psz_variable,
+                           vlc_value_t old_val, vlc_value_t new_val,
+                           void *param );
+static int IntfShowMiningDialogCB( vlc_object_t *p_this, const char *psz_variable,
+                           vlc_value_t old_val, vlc_value_t new_val,
+                           void *param ); 
 
 const QEvent::Type MainInterface::ToolbarsNeedRebuild =
         (QEvent::Type)QEvent::registerEventType();
@@ -99,6 +119,17 @@
     b_hasPausedWhenMinimized = false;
     i_kc_offset          = false;
 
+    p2p_info = "";
+    p2p_status = "";
+    p2p_error = "";
+    m_link_2_open_later = "";
+    m_link_2_open_aceweb = false;
+    m_link_2_open_args = "";
+    m_request_pause_ad = false;
+    ieBrowser = 0;
+    mIeDeleteTimer = 0;
+    m_last_webstat_play_id = "";
+
     /* Ask for Privacy */
     FirstRun::CheckAndRun( this, p_intf );
 
@@ -161,7 +192,7 @@
      * Status Bar *
      **************/
     createStatusBar();
-    setStatusBarVisibility( getSettings()->value( "MainWindow/status-bar-visible", false ).toBool() );
+    setStatusBarVisibility( getSettings()->value( "MainWindow/status-bar-visible", true ).toBool() );
 
     /********************
      * Input Manager    *
@@ -214,11 +245,18 @@
         {
             CONNECT( this, askVideoToResize( unsigned int, unsigned int ),
                      this, setVideoSize( unsigned int, unsigned int ) );
-            CONNECT( videoWidget, sizeChanged( int, int ),
-                     this, videoSizeChanged( int,  int ) );
+            if( b_videoEmbedded ) {
+                CONNECT( videoWidget, sizeChanged( int, int ),
+                        this, videoSizeChanged( int,  int ) );
+            }
         }
         CONNECT( this, askVideoSetFullScreen( bool ),
                  this, setVideoFullScreen( bool ) );
+
+        CONNECT( THEMIM, nothingToPlay(), this, imNothongToPlay() );
+        CONNECT( videoWidget, closeBackgroundScreen(), this, imNothongToPlay() );
+
+        CONNECT( this, backgroundText( QString ), videoWidget, backgroundPrintMessage( QString ) );
     }
 
     CONNECT( THEDP, toolBarConfUpdated(), this, toolBarConfUpdated() );
@@ -229,8 +267,28 @@
     CONNECT( this, askBoss(), this, setBoss() );
     CONNECT( this, askRaise(), this, setRaise() );
 
+    CONNECT( this, askUserData(), this, showUserData() );
+    CONNECT( this, askErrorDialog(QString, QString), this, showErrorDialog(QString, QString) );
+    CONNECT( this, askMiningDialog(int), this, showMiningDialog(int) );
+    
+    CONNECT( THEMIM, p2pInfoChanged(const QString&), this, p2pUpdateInfo(const QString&) );
+    CONNECT( THEMIM, p2pStatusChanged(const QString&), this, p2pUpdateStatus(const QString&) );
+    CONNECT( THEMIM, p2pErrorChanged(const QString&), this, p2pUpdateError(const QString&) );
+    
+    CONNECT( THEMIM->getIM(), enableSaveButton( bool ), this, updateMinWidth() );
+    CONNECT( THEMIM->getIM(), enableLiveStreamButton( bool ), this, updateMinWidth() );
+    CONNECT( THEMIM->getIM(), enableQualitiesButton( QStringList, int ), this, updateMinWidth() );
+    
+    CONNECT( THEMIM->getIM(), inputIsAdvertisement(bool), this, toogleAdvertisementPanel(bool) );
     /** END of CONNECTS**/
 
+    browserManager = new AceWebBrowser::BrowserManager(this);
+    CONNECT(THEMIM, loadUrlEvent(const AceWebBrowser::LoadItem &), this, handleLoadUrlEvent(const AceWebBrowser::LoadItem &));
+    CONNECT(THEMIM, clearLoadUrlEvent(AceWebBrowser::BrowserType), this, handleClearLoadUrlEvent(AceWebBrowser::BrowserType));
+    CONNECT(THEMIM->getIM(), voutChanged( bool ), this, handleVoutChanged(bool));
+    CONNECT(THEMIM, userPauseAction(), this, handleUserPauseAction());
+    CONNECT(THEMIM, userStopAction(), this, handleUserStopAction());
+    CONNECT(THEMIM->getIM(), notifyStateChanged(int, bool), this, handleInputState(int, bool));
 
     /************
      * Callbacks
@@ -242,6 +300,9 @@
     /* Register callback for the intf-popupmenu variable */
     var_AddCallback( p_intf->p_libvlc, "intf-popupmenu", PopupMenuCB, p_intf );
 
+    var_AddCallback( THEP2P, "show-userdata-dialog", IntfShowUserDataCB, p_intf );
+    var_AddCallback( THEP2P, "showdialog", IntfShowErrorDialogCB, p_intf );
+    var_AddCallback( THEP2P, "show-mining-dialog", IntfShowMiningDialogCB, p_intf );
 
     /* Final Sizing, restoration and placement of the interface */
     if( settings->value( "MainWindow/playlist-visible", false ).toBool() )
@@ -269,6 +330,16 @@
     if( videoWidget )
         releaseVideoSlot();
 
+    if(mIeDeleteTimer) {
+        mIeDeleteTimer->stop();
+        mIeDeleteTimer->deleteLater();
+    }
+        
+    if(ieBrowser) {
+        ieBrowser->deleteLater();
+        ieBrowser = 0;
+    }
+        
 #ifdef _WIN32
     if( himl )
         ImageList_Destroy( himl );
@@ -311,6 +382,14 @@
     var_DelCallback( p_intf->p_libvlc, "intf-toggle-fscontrol", IntfShowCB, p_intf );
     var_DelCallback( p_intf->p_libvlc, "intf-popupmenu", PopupMenuCB, p_intf );
 
+    var_DelCallback( THEP2P, "show-userdata-dialog", IntfShowUserDataCB, p_intf );
+    var_DelCallback( THEP2P, "showdialog", IntfShowErrorDialogCB, p_intf );
+    var_DelCallback( THEP2P, "show-mining-dialog", IntfShowMiningDialogCB, p_intf );
+
+    if(browserManager) {
+        delete browserManager;
+    }
+
     p_intf->p_sys->p_mi = NULL;
 }
 
@@ -342,9 +421,14 @@
     if( fullscreenControls )
     {
         delete fullscreenControls;
-        fullscreenControls = new FullscreenControllerWidget( p_intf, this );
+        if( b_videoEmbedded )
+            fullscreenControls = new FullscreenControllerWidget( p_intf, this );
+        else
+            fullscreenControls = new FullscreenControllerWidget( p_intf );
         CONNECT( fullscreenControls, keyPressed( QKeyEvent * ),
                  this, handleKeyPress( QKeyEvent * ) );
+        CONNECT( this, enableFsControlsHiding(bool), fullscreenControls, enableHiding(bool) );
+        CONNECT( this, placeFsControls(int, int), fullscreenControls, placeFsControls(int, int) );
         THEMIM->requestVoutUpdate();
     }
 
@@ -378,14 +462,14 @@
     stackCentralW = new QVLCStackedWidget( main );
 
     /* Bg Cone */
-    if ( QDate::currentDate().dayOfYear() >= QT_XMAS_JOKE_DAY
+    /*if ( QDate::currentDate().dayOfYear() >= QT_XMAS_JOKE_DAY
          && var_InheritBool( p_intf, "qt-icon-change" ) )
     {
         bgWidget = new EasterEggBackgroundWidget( p_intf );
         CONNECT( this, kc_pressed(), bgWidget, animate() );
     }
-    else
-        bgWidget = new BackgroundWidget( p_intf );
+    else */
+    bgWidget = new BackgroundWidget( p_intf );
 
     stackCentralW->addWidget( bgWidget );
     if ( !var_InheritBool( p_intf, "qt-bgcone" ) )
@@ -395,11 +479,15 @@
             bgWidget->setExpandstoHeight( true );
 
     /* And video Outputs */
+    videoWidget = new VideoWidget( p_intf );
     if( b_videoEmbedded )
     {
-        videoWidget = new VideoWidget( p_intf );
         stackCentralW->addWidget( videoWidget );
     }
+
+    browserPlaceholder = new BrowserHolder(this);
+    stackCentralW->addWidget( browserPlaceholder );
+
     mainLayout->insertWidget( 1, stackCentralW );
 
     stackWidgetsSizes[bgWidget] =
@@ -434,9 +522,14 @@
         /* Create the FULLSCREEN CONTROLS Widget */
         if( var_InheritBool( p_intf, "qt-fs-controller" ) )
         {
-            fullscreenControls = new FullscreenControllerWidget( p_intf, this );
+            if( b_videoEmbedded )
+                fullscreenControls = new FullscreenControllerWidget( p_intf, this );
+            else
+                fullscreenControls = new FullscreenControllerWidget( p_intf );
             CONNECT( fullscreenControls, keyPressed( QKeyEvent * ),
                      this, handleKeyPress( QKeyEvent * ) );
+            CONNECT( this, enableFsControlsHiding(bool), fullscreenControls, enableHiding(bool) );
+            CONNECT( this, placeFsControls(int, int), fullscreenControls, placeFsControls(int, int) );
         }
 }
 
@@ -535,7 +628,13 @@
 #endif
 }
 
-inline void MainInterface::showVideo() { showTab( videoWidget ); }
+inline void MainInterface::showVideo() 
+{
+    if(b_videoEmbedded)
+        showTab( videoWidget ); 
+    else
+        videoWidget->show();
+}
 inline void MainInterface::restoreStackOldWidget()
             { showTab( stackCentralOldWidget ); }
 
@@ -549,42 +648,51 @@
                  stackCentralW->indexOf( stackCentralOldWidget ) );
     msg_Dbg( p_intf, "ShowTab request for %s", widget->metaObject()->className() );
 #endif
+    if ( widget == browserPlaceholder ) {
+        stackCentralOldWidget = stackCentralW->currentWidget();
+        stackWidgetsSizes[widget] = stackCentralW->size();
+    }
+
     /* fixing when the playlist has been undocked after being hidden.
        restoreStackOldWidget() is called when video stops but
        stackCentralOldWidget would still be pointing to playlist */
     if ( widget == playlistWidget && !isPlDocked() )
         widget = bgWidget;
 
-    stackCentralOldWidget = stackCentralW->currentWidget();
-    stackWidgetsSizes[stackCentralOldWidget] = stackCentralW->size();
-
-    /* If we are playing video, embedded */
-    if( videoWidget && THEMIM->getIM()->hasVideo() )
-    {
-        /* Video -> Playlist */
-        if( videoWidget == stackCentralOldWidget && widget == playlistWidget )
-        {
-            stackCentralW->removeWidget( videoWidget );
-            videoWidget->show(); videoWidget->raise();
-        }
+    if( stackCentralW->currentWidget() != widget ) {
+        stackCentralOldWidget = stackCentralW->currentWidget();
+        stackWidgetsSizes[stackCentralOldWidget] = stackCentralW->size();
+    }
 
-        /* Playlist -> Video */
-        if( playlistWidget == stackCentralOldWidget && widget == videoWidget )
+    if ( widget != browserPlaceholder ) {
+        /* If we are playing video, embedded */
+        if( videoWidget && THEMIM->getIM()->hasVideo() )
         {
-            playlistWidget->artContainer->removeWidget( videoWidget );
-            videoWidget->show(); videoWidget->raise();
-            stackCentralW->addWidget( videoWidget );
-        }
+            /* Video -> Playlist */
+            if( videoWidget == stackCentralOldWidget && widget == playlistWidget )
+            {
+                stackCentralW->removeWidget( videoWidget );
+                videoWidget->show(); videoWidget->raise();
+            }
 
-        /* Embedded playlist -> Non-embedded playlist */
-        if( bgWidget == stackCentralOldWidget && widget == videoWidget )
-        {
-            /* In rare case when video is started before the interface */
-            if( playlistWidget != NULL )
+            /* Playlist -> Video */
+            if( playlistWidget == stackCentralOldWidget && widget == videoWidget )
+            {
                 playlistWidget->artContainer->removeWidget( videoWidget );
-            videoWidget->show(); videoWidget->raise();
-            stackCentralW->addWidget( videoWidget );
-            stackCentralW->setCurrentWidget( videoWidget );
+                videoWidget->show(); videoWidget->raise();
+                stackCentralW->addWidget( videoWidget );
+            }
+
+            /* Embedded playlist -> Non-embedded playlist */
+            if( bgWidget == stackCentralOldWidget && widget == videoWidget )
+            {
+                /* In rare case when video is started before the interface */
+                if( playlistWidget != NULL )
+                    playlistWidget->artContainer->removeWidget( videoWidget );
+                videoWidget->show(); videoWidget->raise();
+                stackCentralW->addWidget( videoWidget );
+                stackCentralW->setCurrentWidget( videoWidget );
+            }
         }
     }
 
@@ -689,19 +797,27 @@
     assert( videoWidget );
     videoWidget->release();
     setVideoOnTop( false );
+
+    if( b_videoFullScreen ) return;
+
     setVideoFullScreen( false );
 
-    if( stackCentralW->currentWidget() == videoWidget )
-        restoreStackOldWidget();
-    else if( playlistWidget &&
-             playlistWidget->artContainer->currentWidget() == videoWidget )
+    if( b_videoEmbedded )
     {
-        playlistWidget->artContainer->setCurrentIndex( 0 );
-        stackCentralW->addWidget( videoWidget );
-    }
+        if( stackCentralW->currentWidget() == videoWidget )
+            restoreStackOldWidget();
+        else if( playlistWidget &&
+                playlistWidget->artContainer->currentWidget() == videoWidget )
+        {
+            playlistWidget->artContainer->setCurrentIndex( 0 );
+            stackCentralW->addWidget( videoWidget );
+        }
 
-    /* We don't want to have a blank video to popup */
-    stackCentralOldWidget = bgWidget;
+        /* We don't want to have a blank video to popup */
+        stackCentralOldWidget = bgWidget;
+    }
+    else
+        videoWidget->hide();
 }
 
 void MainInterface::setVideoSize( unsigned int w, unsigned int h )
@@ -719,6 +835,7 @@
 void MainInterface::setVideoFullScreen( bool fs )
 {
     b_videoFullScreen = fs;
+    var_SetBool( THEP2P, "vout-display-fullscreen", fs );
     if( fs )
     {
         int numscreen = var_InheritInteger( p_intf, "qt-fullscreen-screennumber" );
@@ -746,15 +863,31 @@
 
         /* */
         setMinimalView( true );
-        setInterfaceFullScreen( true );
+        if( b_videoEmbedded ) {
+            setInterfaceFullScreen(true);
+        }
+        else {
+            videoWidget->setWindowState(videoWidget->windowState() | Qt::WindowFullScreen);
+        }
+        
+        if(THEMIM->getIM()->isP2P() && !THEMIM->getIM()->isAd()) {
+            p2p_RequestLoadUrlAd(THEP2P, P2P_LOAD_URL_WEBSTAT_FULLSCREEN, 0);
+        }
     }
     else
     {
         /* TODO do we want to restore screen and position ? (when
          * qt-fullscreen-screennumber is forced) */
         setMinimalView( b_minimalView );
-        setInterfaceFullScreen( b_interfaceFullScreen );
+        if( b_videoEmbedded ) {
+            setInterfaceFullScreen( b_interfaceFullScreen );
+        }
+        else {
+            videoWidget->setWindowState( videoWidget->windowState() & ~Qt::WindowFullScreen);
+        }
+        updateMinWidth();
     }
+    emit notifyFullscreenChanged(fs);
     videoWidget->sync();
 }
 
@@ -1002,6 +1135,13 @@
 void MainInterface::setName( const QString& name )
 {
     input_name = name; /* store it for the QSystray use */
+
+    if( name == "" ) {
+        p2p_info = "";
+        p2p_status = "";
+        p2p_error = "";
+    }
+
     /* Display it in the status bar, but also as a Tooltip in case it doesn't
        fit in the label */
     nameLabel->setText( name );
@@ -1016,11 +1156,11 @@
 {
     if( aTitle.isEmpty() )
     {
-        setWindowTitle( qtr( "VLC media player" ) );
+        setWindowTitle( qtr( P2P_APP_NAME ) + " (VLC)" );
     }
     else
     {
-        setWindowTitle( aTitle + " - " + qtr( "VLC media player" ) );
+        setWindowTitle( aTitle + " - " + qtr( P2P_APP_NAME ) + " (VLC)" );
     }
 }
 
@@ -1059,9 +1199,9 @@
     else
         iconVLC = QIcon::fromTheme( "vlc", QIcon( ":/logo/vlc256.png" ) );
     sysTray = new QSystemTrayIcon( iconVLC, this );
-    sysTray->setToolTip( qtr( "VLC media player" ));
+    sysTray->setToolTip( qtr( P2P_APP_NAME )+ " (VLC)" );
 
-    systrayMenu = new QMenu( qtr( "VLC media player" ), this );
+    systrayMenu = new QMenu( qtr( P2P_APP_NAME )+ " (VLC)", this );
     systrayMenu->setIcon( iconVLC );
 
     VLCMenuBar::updateSystrayMenu( this, p_intf, true );
@@ -1161,7 +1301,7 @@
 #endif
             break;
         case QSystemTrayIcon::MiddleClick:
-            sysTray->showMessage( qtr( "VLC media player" ),
+            sysTray->showMessage( qtr( P2P_APP_NAME )+ " (VLC)",
                     qtr( "Control menu for the player" ),
                     QSystemTrayIcon::Information, 3000 );
             break;
@@ -1178,7 +1318,7 @@
 {
     if( name.isEmpty() )
     {
-        sysTray->setToolTip( qtr( "VLC media player" ) );
+        sysTray->setToolTip( qtr( P2P_APP_NAME )+ " (VLC)" );
     }
     else
     {
@@ -1186,7 +1326,7 @@
         if( ( i_notificationSetting == NOTIFICATION_ALWAYS ) ||
             ( i_notificationSetting == NOTIFICATION_MINIMIZED && (isMinimized() || isHidden()) ) )
         {
-            sysTray->showMessage( qtr( "VLC media player" ), name,
+            sysTray->showMessage( qtr( P2P_APP_NAME )+ " (VLC)", name,
                     QSystemTrayIcon::NoIcon, 3000 );
         }
     }
@@ -1209,7 +1349,7 @@
         sysTray->setToolTip( input_name + " - " + qtr( "Paused") );
         break;
     default:
-        sysTray->setToolTip( qtr( "VLC media player" ) );
+        sysTray->setToolTip( qtr( P2P_APP_NAME )+ " (VLC)" );
         break;
     }
     VLCMenuBar::updateSystrayMenu( this, p_intf );
@@ -1308,9 +1448,18 @@
             }
             if( mrl.length() > 0 )
             {
-                playlist_Add( THEPL, qtu(mrl), NULL,
-                          PLAYLIST_APPEND | (first ? PLAYLIST_GO: PLAYLIST_PREPARSE),
-                          PLAYLIST_END, b_playlist, pl_Unlocked );
+                p2p_uri_id_type_t p2p_uri_type;
+                p2p_uri_type = p2p_GetIdTypeWithOptString( url.toEncoded().constData(), NULL );
+                if( p2p_uri_type == P2P_TYPE_UNSUPPORT ) {
+                    playlist_Add( THEPL, qtu(mrl), NULL,
+                            PLAYLIST_APPEND | (first ? PLAYLIST_GO: PLAYLIST_PREPARSE),
+                            PLAYLIST_END, b_playlist, pl_Unlocked );
+                }
+                else {
+                    p2p_LoadWithOptString( THEP2P, qtu(mrl), NULL, p2p_uri_type, p2p_LoadAsync, NULL, 
+                                PLAYLIST_APPEND, p2p_LoadAddInput, NULL, 
+                                b_playlist, first, P2P_DEV, P2P_AFF, P2P_ZONE, pl_Unlocked );
+                }
                 first = false;
                 RecentsMRL::getInstance( p_intf )->addRecent( mrl );
             }
@@ -1323,10 +1472,20 @@
     if( !mimeData->hasUrls() && mimeData->hasText() &&
         QUrl(mimeData->text()).isValid() )
     {
-        QString mrl = toURI( mimeData->text() );
-        playlist_Add( THEPL, qtu(mrl), NULL,
-                      PLAYLIST_APPEND | (first ? PLAYLIST_GO: PLAYLIST_PREPARSE),
-                      PLAYLIST_END, b_playlist, pl_Unlocked );
+        p2p_uri_id_type_t p2p_uri_type;
+        p2p_uri_type = p2p_GetIdTypeWithOptString(qtu(mimeData->text()), NULL);
+        if( p2p_uri_type == P2P_TYPE_UNSUPPORT ) {
+            QString mrl = toURI( mimeData->text() );
+            playlist_Add( THEPL, qtu(mrl), NULL,
+                        PLAYLIST_APPEND | (first ? PLAYLIST_GO: PLAYLIST_PREPARSE),
+                        PLAYLIST_END, b_playlist, pl_Unlocked );
+        }
+        else {
+            QString mrl = (p2p_uri_type != P2P_TYPE_PLAYER && p2p_uri_type != P2P_TYPE_RAW) ? toURI( mimeData->text() ) : mimeData->text();
+            p2p_LoadWithOptString( THEP2P, qtu(mrl), NULL, p2p_uri_type, p2p_LoadAsync, NULL, 
+                                PLAYLIST_APPEND, p2p_LoadAddInput, NULL, 
+                                b_playlist, first, P2P_DEV, P2P_AFF, P2P_ZONE, pl_Unlocked );
+        }
     }
     event->accept();
 }
@@ -1351,7 +1510,7 @@
     handleKeyPress( e );
 
     /* easter eggs sequence handling */
-    if ( e->key() == kc[ i_kc_offset ] )
+    /*if ( e->key() == kc[ i_kc_offset ] )
         i_kc_offset++;
     else
         i_kc_offset = 0;
@@ -1360,7 +1519,7 @@
     {
         i_kc_offset = 0;
         emit kc_pressed();
-    }
+    }*/
 }
 
 void MainInterface::handleKeyPress( QKeyEvent *e )
@@ -1375,7 +1534,16 @@
     int i_vlck = qtEventToVLCKey( e );
     if( i_vlck > 0 )
     {
-        var_SetInteger( p_intf->p_libvlc, "key-pressed", i_vlck );
+        uint32_t action = vlc_GetActionByKey(p_intf, i_vlck);
+        if( action == ACTIONID_PLAY_PAUSE ) {
+            THEAM->play();
+        }
+        else if( action == ACTIONID_STOP ) {
+            THEMIM->stop();
+        }
+        else {
+            var_SetInteger( p_intf->p_libvlc, "key-pressed", i_vlck );
+        }
         e->accept();
     }
     else
@@ -1385,10 +1553,20 @@
 void MainInterface::wheelEvent( QWheelEvent *e )
 {
     int i_vlckey = qtWheelEventToVLCKey( e );
+    uint32_t action = vlc_GetActionByKey(p_intf, i_vlckey);
+    if(action == ACTIONID_VOL_UP || action == ACTIONID_VOL_DOWN) {
+       THEMIM->getIM()->dropCachedVolume(); 
+    }
     var_SetInteger( p_intf->p_libvlc, "key-pressed", i_vlckey );
     e->accept();
 }
 
+void MainInterface::resizeEvent(QResizeEvent *e)
+{
+    emit notifySizeChanged(e->size());
+    e->ignore();
+}
+
 void MainInterface::closeEvent( QCloseEvent *e )
 {
 //  hide();
@@ -1455,6 +1633,606 @@
     raise();
 }
 
+void MainInterface::p2pUserDataDialogShow()
+{
+    emit askUserData();
+}
+
+void MainInterface::p2pErrorDialogShow(const QString& title, const QString& text)
+{
+    emit askErrorDialog(title, text);
+}
+
+void MainInterface::p2pMiningDialogShow(int type) 
+{
+    emit askMiningDialog(type);
+}
+
+void MainInterface::showUserData()
+{
+    UserInfoWidget::ShowUserInfoDialog( this, p_intf );
+}
+
+void MainInterface::showErrorDialog(QString title, QString text)
+{
+    if(title.size() <= 0)
+        title = "Error";
+    dialog_Fatal( THEP2P, qtu(title), qtu(text) );
+}
+
+void MainInterface::showMiningDialog(int type)
+{
+    MiningInfoWidget::ShowMiningDialog( this, p_intf, type );
+}
+
+void MainInterface::p2pUpdateInfo( const QString &info )
+{
+    p2p_info = info;
+    updateTextLabels();
+}
+
+void MainInterface::p2pUpdateStatus( const QString &status )
+{
+    p2p_status = status;
+    if( p2p_error.size() > 0 )
+        p2p_error = "";
+    updateTextLabels();
+}
+
+void MainInterface::p2pUpdateError( const QString &error )
+{
+    p2p_error = error;
+    updateTextLabels();
+}
+
+void MainInterface::updateTextLabels()
+{
+    input_item_t *p_input_item = THEMIM->currentInputItem();
+    if( (p_input_item && input_item_IsP2P(p_input_item)) || !p_input_item ) {
+        if( p2p_error.size() > 0 ) {
+            nameLabel->setText( p2p_error );
+            nameLabel->setToolTip( p2p_error );
+            emit backgroundText( p2p_error );
+        }
+        else if( p2p_info.size() > 0 ) {
+            nameLabel->setText( p2p_info );
+            nameLabel->setToolTip( p2p_info );
+            emit backgroundText( p2p_info );
+        }
+        else if(p2p_status.size()>0) {
+            nameLabel->setText( p2p_status );
+            nameLabel->setToolTip( p2p_status );
+            emit backgroundText( p2p_status );
+        }
+        else if( p_input_item && (input_item_GetP2PIsAdFlag( p_input_item ) || input_item_GetP2PIsIntAdFlag( p_input_item )) ) {
+            nameLabel->setText( " " );
+            nameLabel->setToolTip( " " );
+        }
+        else {
+            nameLabel->setText( input_name + " " );
+            nameLabel->setToolTip( input_name + " " );
+        }
+    }
+    else {
+        nameLabel->setText( input_name + " " );
+        nameLabel->setToolTip( input_name + " " );
+        emit backgroundText( "" );
+    }
+}
+
+void MainInterface::updateMinWidth()
+{
+    computeMinimumSize();
+}
+
+void MainInterface::imNothongToPlay()
+{
+    if( b_videoFullScreen ) {
+        setVideoFullScreen( false );
+    
+        if( b_videoEmbedded ) {
+            if( stackCentralW->currentWidget() == videoWidget )
+                restoreStackOldWidget();
+            else if( playlistWidget &&
+                    playlistWidget->artContainer->currentWidget() == videoWidget )
+            {
+                playlistWidget->artContainer->setCurrentIndex( 0 );
+                stackCentralW->addWidget( videoWidget );
+            }
+            stackCentralOldWidget = bgWidget;
+        }
+        else
+            videoWidget->hide();
+    }
+}
+
+
+
+
+
+void MainInterface::toogleAdvertisementPanel(bool val)
+{
+    controls->toogleAdvertisementPanel(val);
+    if( fullscreenControls ) 
+        fullscreenControls->toogleAdvertisementPanel(val);
+}
+
+/*****************************************
+ *****************************************/
+void MainInterface::handleLoadUrlEvent(const AceWebBrowser::LoadItem &conf) 
+{
+    createBrowser(conf);
+}
+
+void MainInterface::handleClearLoadUrlEvent(AceWebBrowser::BrowserType type) 
+{
+    if(browserManager) {
+        browserManager->closeBrowser(type);
+    }
+}
+
+void MainInterface::createBrowser(AceWebBrowser::LoadItem conf) 
+{
+    if(!browserManager) return;
+    if(conf.type() != AceWebBrowser::BTYPE_PREROLL && !THEMIM->getIM()->isP2P()) return;
+    if(m_request_pause_ad) return;
+
+    qDebug() << "Player::createBrowser:" << conf;
+    
+    if(conf.type() == AceWebBrowser::BTYPE_WEBSTAT && conf.urlWithId()->id().startsWith("webstat-play")) {
+        qDebug() << "Player::createBrowser: check webstat play: id =" << conf.urlWithId()->id() << "last =" << m_last_webstat_play_id;
+        if(conf.urlWithId()->id() == m_last_webstat_play_id) {
+            qDebug() << "Player::createBrowser: webstat play already loaded: id =" << m_last_webstat_play_id;
+            return;
+        }
+        m_last_webstat_play_id = conf.urlWithId()->id();
+    }
+    
+    QString aceHost = "";
+    char *psz_host = var_GetString(THEP2P, "engine-http-host");
+    if(psz_host) {
+        aceHost.sprintf( "%s", psz_host );
+        free(psz_host);
+    }
+    int acePort = 0;
+    acePort = var_GetInteger(THEP2P, "engine-http-port");
+    
+    conf.setHostUserAgent("AcePlayer/"P2P_STD_VERSION"");
+    conf.setEngineHttpHost(aceHost);
+    conf.setEngineHttpPort(acePort);
+    QWidget *parent = 0;
+    if(conf.type() == AceWebBrowser::BTYPE_PAUSE 
+        || conf.type() == AceWebBrowser::BTYPE_OVERLAY 
+        || conf.type() == AceWebBrowser::BTYPE_SLIDER 
+        || conf.type() == AceWebBrowser::BTYPE_HIDDEN) {
+        parent = videoWidget;
+    }
+    else if (conf.type() == AceWebBrowser::BTYPE_PREROLL || conf.type() == AceWebBrowser::BTYPE_WEBSTAT) {
+        //|| conf.type() == AceWebBrowser::BTYPE_STOP) {
+        parent = browserPlaceholder;
+    }
+    if(!parent) return;
+    
+    if(conf.type() == AceWebBrowser::BTYPE_PREROLL && conf.useIE()) {
+        createIEBrowser(conf, parent);
+        return;
+    }
+    
+    AceWebBrowser::Browser *browser = browserManager->createBrowser(conf, parent);
+    
+    if(conf.type() == AceWebBrowser::BTYPE_PAUSE) {
+        if(browser->isVisible()) {
+            qDebug() << "Player::createBrowser: got visible pause browser, skip reloading";
+            return;
+        }
+    }
+    
+    browser->setPlayerFullscreen(b_videoFullScreen);
+    browser->setPlayerState(THEMIM->getIM()->playingStatus(), THEMIM->getIM()->isAd());
+    
+    // player notifications
+    connect(parent, SIGNAL(notifySizeChanged(QSize)), browser, SLOT(handleParentSize(QSize)), Qt::UniqueConnection);
+    
+    connect(THEMIM->getIM(), SIGNAL(notifyStateChanged(int, bool)),
+            browser, SLOT(handleParentState(int, bool)), Qt::UniqueConnection);
+    connect(this, SIGNAL(notifyFullscreenChanged(bool)),
+            browser, SLOT(handleParentFullscreen(bool)), Qt::UniqueConnection);
+    connect(this, SIGNAL(notifyPauseClicked()),
+            browser, SLOT(handleParentPauseClicked()), Qt::UniqueConnection);
+    // browser register events
+    connect(browser, SIGNAL(registerBrowserShownEvent(AceWebBrowser::BrowserType,QString)),
+            SLOT(registerShow(AceWebBrowser::BrowserType,QString)), Qt::UniqueConnection);
+    connect(browser, SIGNAL(registerBrowserHideEvent(AceWebBrowser::BrowserType,QString)),
+            SLOT(registerHide(AceWebBrowser::BrowserType,QString)), Qt::UniqueConnection);
+    connect(browser, SIGNAL(registerBrowserClosedEvent(AceWebBrowser::BrowserType,QString,bool,bool,int)),
+            SLOT(registerClosed(AceWebBrowser::BrowserType,QString,bool,bool,int)), Qt::UniqueConnection);
+    connect(browser, SIGNAL(registerBrowserErrorEvent(AceWebBrowser::BrowserType,QString)),
+            SLOT(registerError(AceWebBrowser::BrowserType,QString)), Qt::UniqueConnection);
+    connect(browser, SIGNAL(registerSendEvent(AceWebBrowser::BrowserType, QString, QString)),
+            SLOT(registerBrowserSendEvent(AceWebBrowser::BrowserType, QString, QString)), Qt::UniqueConnection);
+    // browser notifications
+    connect(browser, SIGNAL(notifyBrowserVisiabilityChanged(AceWebBrowser::BrowserType,bool)),
+            SLOT(handleBrowserVisiability(AceWebBrowser::BrowserType,bool)), Qt::UniqueConnection);
+    connect(browser, SIGNAL(notifyParentCommandToShow(AceWebBrowser::BrowserType)),
+            SLOT(handleParentCommandToShow(AceWebBrowser::BrowserType)), Qt::UniqueConnection);
+    connect(browser, SIGNAL(notifyNeedExitFullscreen()), SLOT(handleExitFullscreen()), Qt::UniqueConnection);
+    connect(browser, SIGNAL(notifyBrowserPosition(AceWebBrowser::BrowserType, const QPoint&, const QSize&)), 
+            SLOT(handleBrowserPosition(AceWebBrowser::BrowserType, const QPoint&, const QSize&)), Qt::UniqueConnection);
+    // javascript object
+    connect(parent, SIGNAL(notifySizeChanged(QSize)),
+            browser->javaScriptObject(), SLOT(handlePlayerSizeChanged(QSize)), Qt::UniqueConnection);
+    connect(browser->javaScriptObject(), SIGNAL(jsoPlayerPlay()),
+            SLOT(handleJSOPlay()), Qt::UniqueConnection);
+    connect(browser->javaScriptObject(), SIGNAL(jsoPlayerPause()),
+            SLOT(handleJSOPause()), Qt::UniqueConnection);
+    connect(browser->javaScriptObject(), SIGNAL(jsoPlayerStop()),
+            SLOT(handleJSOStop()), Qt::UniqueConnection);
+    connect(browser->javaScriptObject(), SIGNAL(jsoLinkOpenLater(QString, bool, bool, QString)),
+            SLOT(handleJSOLinkOpenLater(QString, bool, bool, QString)), Qt::UniqueConnection);
+    /*connect(ieBrowser->javaScriptObject(), SIGNAL(jsoPlayerSetFullscreen(bool)),
+            SLOT(handleJSOSetFullscreen(bool)), Qt::UniqueConnection);*/
+    connect(browser->javaScriptObject(), SIGNAL(jsoPlayerToggleFullscreen()),
+            SLOT(handleJSOToggleFullscreen()), Qt::UniqueConnection);
+    browser->load(conf);
+}
+
+void MainInterface::createIEBrowser(AceWebBrowser::LoadItem conf, QWidget *parent)
+{
+    qWarning() << "Player::createIEBrowser";
+    if(mIeDeleteTimer && mIeDeleteTimer->isActive()) {
+        mIeDeleteTimer->stop();
+    }
+    if(!ieBrowser) {
+        try {
+            ieBrowser = new AceWebBrowser::IEBrowser2(conf, parent);
+        }
+        catch(AceWebBrowser::BrowserException *e) {
+            qWarning() << "Player::createIEBrowser: Exception:" << e->message();
+            registerIEError(e->type(), e->id());
+            ieBrowser = 0;
+            return;
+        }
+        
+        // player notifications
+        connect(parent, SIGNAL(notifySizeChanged(QSize)),
+                ieBrowser, SLOT(handleParentSize(QSize)), Qt::UniqueConnection);
+        connect(THEMIM->getIM(), SIGNAL(notifyStateChanged(int, bool)),
+                ieBrowser, SLOT(handleParentState(int, bool)), Qt::UniqueConnection);
+        connect(this, SIGNAL(notifyFullscreenChanged(bool)),
+                ieBrowser, SLOT(handleParentFullscreen(bool)), Qt::UniqueConnection);
+        // browser register events
+        connect(ieBrowser, SIGNAL(registerBrowserSuccessEvent(AceWebBrowser::BrowserType,QString)),
+                SLOT(registerIESuccess(AceWebBrowser::BrowserType,QString)), Qt::UniqueConnection);
+        connect(ieBrowser, SIGNAL(registerBrowserErrorEvent(AceWebBrowser::BrowserType,QString)),
+                SLOT(registerIEError(AceWebBrowser::BrowserType,QString)), Qt::UniqueConnection);
+        connect(ieBrowser, SIGNAL(registerBrowserSendEvent(AceWebBrowser::BrowserType,QString,QString)),
+                SLOT(registerBrowserSendEvent(AceWebBrowser::BrowserType,QString,QString)), Qt::UniqueConnection);
+        // browser notifications
+        connect(ieBrowser, SIGNAL(notifyBrowserVisiabilityChanged(AceWebBrowser::BrowserType,bool)),
+            SLOT(handleBrowserVisiability(AceWebBrowser::BrowserType,bool)), Qt::UniqueConnection);
+        connect(ieBrowser, SIGNAL(notifyParentCommandToShow(AceWebBrowser::BrowserType)),
+                SLOT(handleParentCommandToShow(AceWebBrowser::BrowserType)), Qt::UniqueConnection);
+        connect(ieBrowser, SIGNAL(notifyNeedExitFullscreen()), SLOT(handleExitFullscreen()), Qt::UniqueConnection);
+        // javascript object
+        connect(parent, SIGNAL(notifySizeChanged(QSize)),
+                ieBrowser->javaScriptObject(), SLOT(handlePlayerSizeChanged(QSize)), Qt::UniqueConnection);
+        connect(ieBrowser->javaScriptObject(), SIGNAL(jsoPlayerPlay()),
+                SLOT(handleJSOPlay()), Qt::UniqueConnection);
+        connect(ieBrowser->javaScriptObject(), SIGNAL(jsoPlayerPause()),
+                SLOT(handleJSOPause()), Qt::UniqueConnection);
+        connect(ieBrowser->javaScriptObject(), SIGNAL(jsoPlayerStop()),
+                SLOT(handleJSOStop()), Qt::UniqueConnection);
+        connect(ieBrowser->javaScriptObject(), SIGNAL(jsoLinkOpenLater(QString, bool, bool, QString)),
+                SLOT(handleJSOLinkOpenLater(QString, bool, bool, QString)), Qt::UniqueConnection);
+        connect(ieBrowser->javaScriptObject(), SIGNAL(jsoPlayerSetFullscreen(bool)),
+                SLOT(handleJSOSetFullscreen(bool)), Qt::UniqueConnection);
+        connect(ieBrowser->javaScriptObject(), SIGNAL(jsoPlayerToggleFullscreen()),
+            SLOT(handleJSOToggleFullscreen()), Qt::UniqueConnection);
+    }
+    ieBrowser->load(conf);
+}
+
+void MainInterface::registerIESuccess(AceWebBrowser::BrowserType type, QString id)
+{
+    qDebug() << "Player::registerIESuccess: register preroll complete";
+    
+    if(ieBrowser) {
+        statusBar()->clearMessage();
+        if(!mIeDeleteTimer) {
+            mIeDeleteTimer = new QTimer(this);
+            mIeDeleteTimer->setSingleShot(true);
+            connect(mIeDeleteTimer, SIGNAL(timeout()), SLOT(deleteIEBrowser()));
+        }
+        mIeDeleteTimer->setInterval(1000);
+        mIeDeleteTimer->start();
+    }
+    p2p_RegisterLoadUrlAdStatistics(THEP2P, (p2p_load_url_type_t)type, P2P_LOAD_URL_STAT_EVENT_COMPLETE, qtu(id));
+}
+
+void MainInterface::registerIEError(AceWebBrowser::BrowserType type, QString id)
+{
+    qDebug() << "Player::registerIEError: register preroll failed";
+    
+    if(ieBrowser) {
+        statusBar()->clearMessage();
+        if(!mIeDeleteTimer) {
+            mIeDeleteTimer = new QTimer(this);
+            mIeDeleteTimer->setSingleShot(true);
+            connect(mIeDeleteTimer, SIGNAL(timeout()), SLOT(deleteIEBrowser()));
+        }
+        mIeDeleteTimer->setInterval(1000);
+        mIeDeleteTimer->start();
+    }
+    p2p_RegisterLoadUrlAdStatistics(THEP2P, (p2p_load_url_type_t)type, P2P_LOAD_URL_STAT_EVENT_ERROR, qtu(id));
+}
+
+void MainInterface::deleteIEBrowser() {
+    qDebug() << "Player::deleteIEBrowser";
+    if(ieBrowser) {
+        delete ieBrowser;
+        ieBrowser = 0;
+        statusBar()->clearMessage();
+    }
+}
+
+void MainInterface::registerShow(AceWebBrowser::BrowserType type, QString id)
+{
+    qDebug() << "Player::registerShow: type" << (int)type << "id" << id;
+
+    if(type != AceWebBrowser::BTYPE_PREROLL && type != AceWebBrowser::BTYPE_HIDDEN) {
+        qDebug() << "Player::registerShow: register IMPRESSION";
+        p2p_RegisterLoadUrlAdStatistics(THEP2P, (p2p_load_url_type_t)type, P2P_LOAD_URL_STAT_EVENT_IMPRESSION, qtu(id));
+    }
+}
+
+void MainInterface::registerHide(AceWebBrowser::BrowserType type, QString id)
+{
+    qDebug() << "Player::registerHide: type" << (int)type << "id" << id;
+
+    if(type == AceWebBrowser::BTYPE_PREROLL) {
+        p2p_RegisterLoadUrlAdStatistics(THEP2P, (p2p_load_url_type_t)type, P2P_LOAD_URL_STAT_EVENT_COMPLETE, qtu(id));
+    }
+}
+
+void MainInterface::registerClosed(AceWebBrowser::BrowserType type, QString id, bool failed, bool browserMode, int group)
+{
+    qDebug() << "Player::registerClosed: type" << (int)type << "id" << id << "failed" << failed;
+
+    if(!failed) {
+        if(type == AceWebBrowser::BTYPE_PREROLL) {
+            qDebug() << "Player::registerClosed: register COMPLETE";
+            p2p_RegisterLoadUrlAdStatistics(THEP2P, (p2p_load_url_type_t)type, P2P_LOAD_URL_STAT_EVENT_COMPLETE, qtu(id));
+        }
+        else if(type == AceWebBrowser::BTYPE_HIDDEN) {
+            qDebug() << "Player::registerClosed: register COMPLETE_HIDDEN";
+            p2p_RegisterLoadUrlAdStatistics(THEP2P, (p2p_load_url_type_t)type, P2P_LOAD_URL_STAT_EVENT_COMPLETE_HIDDEN, qtu(id));
+        }
+        else if (type == AceWebBrowser::BTYPE_OVERLAY) {
+            qDebug() << "Player::registerClosed: register CLOSE";
+            p2p_RegisterLoadUrlAdStatistics(THEP2P, (p2p_load_url_type_t)type, P2P_LOAD_URL_STAT_EVENT_CLOSE, qtu(id));
+            availableBrowserShowing(AceWebBrowser::BTYPE_PAUSE, true);
+            if(browserMode && THEMIM->getIM()->playingStatus() == PAUSE_S) {
+                THEMIM->togglePlayPause();
+            }
+        }
+        else if (type == AceWebBrowser::BTYPE_PAUSE) {
+            int state = THEMIM->getIM()->playingStatus();
+            if(state == PAUSE_S) {
+                qDebug() << "Player::registerClosed: will request for new pause url after state chaged";
+                m_request_pause_ad = true;
+            }
+            else {
+                qDebug() << "Player::stateChanged: request for new pause url";
+                p2p_RequestLoadUrlAd(THEP2P, P2P_LOAD_URL_PAUSE, 0);
+                m_request_pause_ad = false;
+            }
+        }
+    }
+    if(type == AceWebBrowser::BTYPE_HIDDEN) {
+        p2p_RequestLoadUrlAd(THEP2P, P2P_LOAD_URL_HIDDEN, group);
+    }
+}
+
+void MainInterface::registerError(AceWebBrowser::BrowserType type, QString id)
+{
+    qDebug() << "Player::registerError: type" << type << "id" << id;
+
+    if(type == AceWebBrowser::BTYPE_PREROLL) {
+        qDebug() << "Player::registerError: register ERROR";
+        p2p_RegisterLoadUrlAdStatistics(THEP2P, (p2p_load_url_type_t)type, P2P_LOAD_URL_STAT_EVENT_ERROR, qtu(id));
+    }
+    else if(type == AceWebBrowser::BTYPE_HIDDEN) {
+        qDebug() << "Player::registerError: register ERROR_HIDDEN";
+        p2p_RegisterLoadUrlAdStatistics(THEP2P, (p2p_load_url_type_t)type, P2P_LOAD_URL_STAT_EVENT_ERROR_HIDDEN, qtu(id));
+    }
+}
+
+void MainInterface::registerBrowserSendEvent(AceWebBrowser::BrowserType type, QString event_name, QString id)
+{
+    if(type != AceWebBrowser::BTYPE_PREROLL) return;
+
+    if(event_name.size() > 50)
+        event_name.truncate(50);
+    event_name.remove(QRegExp("[^a-zA-Z0-9\\-\\_]"));
+    p2p_RegisterLoadUrlAdEvent(THEP2P, (p2p_load_url_type_t)type, qtu(event_name), qtu(id));
+}
+
+void MainInterface::handleBrowserVisiability(AceWebBrowser::BrowserType type, bool isVisible)
+{
+    qDebug() << "Player::handleBrowserVisiability: type" << type << "visible" << isVisible << "has_visible" << browserManager->isVisible();
+
+    if(type == AceWebBrowser::BTYPE_PREROLL) {
+        if(!isVisible) {
+            statusBar()->setSizeGripEnabled(true);
+            controls->showMainControls();
+            menuBar()->setVisible(true);
+            if(m_status_bar_visible_cached) {
+                setStatusBarVisibility(true);
+            }
+            inputC->setVisible(true);
+            restoreStackOldWidget();
+        }
+    }
+    
+    if(!isVisible) {
+        if(browserManager && (!browserManager->isVisible() || ieBrowser)){
+            emit enableFsControlsHiding(true);
+            emit placeFsControls(-1, -1);
+        }
+    }
+}
+
+void MainInterface::handleParentCommandToShow(AceWebBrowser::BrowserType type)
+{
+    qDebug() << "Player::handleParentCommandToShow" << type;
+    
+    if(type == AceWebBrowser::BTYPE_PREROLL) {
+        if(ieBrowser) {
+            if(menuBar()->isVisible()) {
+                statusBar()->setSizeGripEnabled(false);
+                controls->hideMainControls();
+                menuBar()->setVisible(false);
+                m_status_bar_visible_cached = b_statusbarVisible;
+                if(b_statusbarVisible) {
+                    setStatusBarVisibility(false);
+                }
+                inputC->setVisible(false);
+                
+                ieBrowser->setVisiabilityProcessingEnable(false);
+                showTab(browserPlaceholder);
+                ieBrowser->setVisiabilityProcessingEnable(true);
+            }
+        }
+        else {
+            AceWebBrowser::Browser *preroll = browserManager->getBrowser(AceWebBrowser::BTYPE_PREROLL);
+            if(preroll && menuBar()->isVisible()) {
+                statusBar()->setSizeGripEnabled(false);
+                controls->hideMainControls();
+                menuBar()->setVisible(false);
+                m_status_bar_visible_cached = b_statusbarVisible;
+                if(b_statusbarVisible) {
+                    setStatusBarVisibility(false);
+                }
+                inputC->setVisible(false);
+                
+                preroll->setVisiabilityProcessingEnable(false);
+                showTab(browserPlaceholder);
+                preroll->setVisiabilityProcessingEnable(true);
+            }
+        }
+    }
+}
+
+void MainInterface::handleBrowserPosition(AceWebBrowser::BrowserType type, const QPoint &p, const QSize &s)
+{
+    if(type == AceWebBrowser::BTYPE_PAUSE || type == AceWebBrowser::BTYPE_OVERLAY) {
+        if(b_videoFullScreen) {
+            QSize videoSize = videoWidget->frameSize();
+            emit enableFsControlsHiding(videoSize.width() > s.width() + 10 && videoSize.height() > s.height() + 10);
+            emit placeFsControls(p.y(), s.height());
+        }
+    }
+}
+
+void MainInterface::handleExitFullscreen()
+{
+    if(b_videoFullScreen) {
+        THEAM->fullscreen();
+    }
+}
+
+void MainInterface::handleJSOPlay()
+{
+    THEMIM->togglePlayPause();
+}
+
+void MainInterface::handleJSOPause()
+{
+    if(THEMIM->getIM()->playingStatus() == PLAYING_S || THEMIM->getIM()->playingStatus() == PAUSE_S) {
+        availableBrowserShowing(AceWebBrowser::BTYPE_PAUSE, false);
+        THEMIM->togglePlayPause();
+    }
+}
+
+void MainInterface::handleJSOStop()
+{
+    THEMIM->stop();
+}
+
+void MainInterface::handleJSOLinkOpenLater(QString url, bool preffered, bool aceweb, QString arguments)
+{
+    (void)preffered;
+    qDebug() << "Player::handleJSOLinkOpenLater:" << url;
+    m_link_2_open_later = url;
+    m_link_2_open_aceweb = aceweb;
+    m_link_2_open_args = arguments;
+}
+
+void MainInterface::handleJSOSetFullscreen(bool fs)
+{
+    qDebug() << "Player::handleJSOSetFullscreen:" << fs;
+    if(b_videoFullScreen != fs) {
+        THEAM->fullscreen();
+    }
+}
+
+void MainInterface::handleJSOToggleFullscreen()
+{
+    qDebug() << "Player::handleJSOToggleFullscreen";
+    THEAM->fullscreen();
+}
+
+void MainInterface::availableBrowserShowing(AceWebBrowser::BrowserType type, bool available)
+{
+    if(browserManager && browserManager->hasBrowser(type)) {
+        AceWebBrowser::Browser *browser = browserManager->getBrowser(type);
+        if(browser) {
+            browser->setShowAvailable(available);
+        }
+    }
+}
+
+void MainInterface::handleVoutChanged(bool hasVout) 
+{
+    if(browserManager) {
+        qDebug() << "checking if videowidget visible" << videoWidget->isVisible() << "has video" << hasVout;
+        browserManager->updateBrowsersOnVoutChanged(hasVout);
+    }
+}
+
+void MainInterface::handleInputState(int state, bool isAd)
+{
+    if(state == AceWebBrowser::BHPS_PLAYING && m_request_pause_ad) {
+        qDebug() << "Player::handleInputState: request for new pause url";
+        p2p_RequestLoadUrlAd(THEP2P, P2P_LOAD_URL_PAUSE, 0);
+        m_request_pause_ad = false;
+    }
+    else if(state == AceWebBrowser::BHPS_PAUSED && !isAd && THEMIM->getIM()->isP2P())
+        p2p_RequestLoadUrlAd(THEP2P, P2P_LOAD_URL_WEBSTAT_PAUSE, 0);
+    else if(state == AceWebBrowser::BHPS_STOPPED && !isAd)
+        p2p_RequestLoadUrlAd(THEP2P, P2P_LOAD_URL_WEBSTAT_STOP, 0);
+}
+
+void MainInterface::handleUserPauseAction()
+{
+    emit notifyPauseClicked();
+}
+
+void MainInterface::handleUserStopAction()
+{
+    if(m_link_2_open_later != "") {
+        if(m_link_2_open_aceweb) {
+            AceWebBrowser::OpenInAceWeb(QUrl(m_link_2_open_later), m_link_2_open_args);
+        }
+        else {
+            QDesktopServices::openUrl(m_link_2_open_later);
+        }
+        m_link_2_open_later = "";
+        m_link_2_open_aceweb = false;
+        m_link_2_open_args = "";
+    }
+}
+
 /*****************************************************************************
  * PopupMenuCB: callback triggered by the intf-popupmenu playlist variable.
  *  We don't show the menu directly here because we don't want the
@@ -1521,3 +2299,47 @@
 
     return VLC_SUCCESS;
 }
+
+static int IntfShowUserDataCB( vlc_object_t *p_this, const char *psz_variable,
+                           vlc_value_t old_val, vlc_value_t new_val, void *param )
+{
+    VLC_UNUSED( p_this ); VLC_UNUSED( psz_variable ); VLC_UNUSED( old_val );
+    VLC_UNUSED( new_val );
+    
+    intf_thread_t *p_intf = (intf_thread_t *)param;
+    p_intf->p_sys->p_mi->p2pUserDataDialogShow();
+
+    return VLC_SUCCESS;
+}
+
+static int IntfShowErrorDialogCB( vlc_object_t *p_this, const char *psz_variable,
+                           vlc_value_t old_val, vlc_value_t new_val, void *param )
+{
+    VLC_UNUSED( p_this ); VLC_UNUSED( psz_variable ); VLC_UNUSED( old_val );
+    
+    intf_thread_t *p_intf = (intf_thread_t *)param;
+    
+    p2p_showdialog_item_t *p_showdialog = (p2p_showdialog_item_t *)new_val.p_address;
+    if( p_showdialog ) {
+        QString title = "";
+        if( p_showdialog->title )
+            title.sprintf( "%s", p_showdialog->title );
+        QString text = "";
+        if( p_showdialog->text )
+            text.sprintf( "%s", p_showdialog->text );
+        p_intf->p_sys->p_mi->p2pErrorDialogShow(title, text);
+    }
+
+    return VLC_SUCCESS;
+}
+
+static int IntfShowMiningDialogCB( vlc_object_t *p_this, const char *psz_variable,
+                           vlc_value_t old_val, vlc_value_t new_val, void *param )
+{
+    VLC_UNUSED( p_this ); VLC_UNUSED( psz_variable ); VLC_UNUSED( old_val );
+    
+    intf_thread_t *p_intf = (intf_thread_t *)param;
+    p_intf->p_sys->p_mi->p2pMiningDialogShow(new_val.i_int);
+    
+    return VLC_SUCCESS;
+}
diff -ru vlc-2.1.2.orig/modules/gui/qt4/main_interface.hpp vlc-2.1.2/modules/gui/qt4/main_interface.hpp
--- vlc-2.1.4.orig/modules/gui/qt4/main_interface.hpp	2014-02-21 15:59:56.000000000 +0200
+++ vlc-2.1.4/modules/gui/qt4/main_interface.hpp	2014-05-13 15:08:24.000000000 +0300
@@ -33,6 +33,10 @@
  #include <vlc_windows_interfaces.h>
 #endif
 
+#include <ole2.h>
+#include <windows.h>
+#include "acewebbrowser/browsermanager.hpp"
+#include "acewebbrowser/iebrowser2.hpp"
 #include <QSystemTrayIcon>
 #include <QStackedWidget>
 
@@ -55,6 +59,8 @@
 class QMenu;
 class QSize;
 class StandardPLPanel;
+class BrowserHolder;
+class QTimer;
 
 class MainInterface : public QVLCMW
 {
@@ -105,6 +111,7 @@
     virtual void keyPressEvent( QKeyEvent *);
     virtual void wheelEvent( QWheelEvent * );
     virtual bool eventFilter(QObject *, QEvent *);
+    virtual void resizeEvent(QResizeEvent *);
 
 private:
     /* Main Widgets Creation */
@@ -183,6 +190,10 @@
 
     static const Qt::Key kc[10]; /* easter eggs */
     int i_kc_offset;
+    
+    QString p2p_info;
+    QString p2p_status;
+    QString p2p_error;
 
 public slots:
     void dockPlaylist( bool b_docked = true );
@@ -266,6 +277,86 @@
     void askBoss();
     void askRaise();
     void kc_pressed(); /* easter eggs */
+
+public slots:
+    void p2pUserDataDialogShow();
+    void p2pErrorDialogShow(const QString&, const QString&);
+    void p2pMiningDialogShow(int);
+    void p2pUpdateInfo(const QString&);
+    void p2pUpdateStatus(const QString&);
+    void p2pUpdateError(const QString&);
+    void updateMinWidth();
+
+private slots:
+    void showUserData();
+    void showErrorDialog(QString, QString);
+    void showMiningDialog(int);
+    void updateTextLabels();
+    void imNothongToPlay();
+    void toogleAdvertisementPanel(bool);
+    
+    void handleLoadUrlEvent(const AceWebBrowser::LoadItem &conf);
+    void handleClearLoadUrlEvent(AceWebBrowser::BrowserType type);
+    void createBrowser(AceWebBrowser::LoadItem conf);
+    void createIEBrowser(AceWebBrowser::LoadItem conf, QWidget *parent); //tmp
+
+
+
+    void registerShow(AceWebBrowser::BrowserType type, QString id);
+    void registerHide(AceWebBrowser::BrowserType type, QString id);
+    void registerClosed(AceWebBrowser::BrowserType type, QString id, bool failed, bool, int);
+    void registerError(AceWebBrowser::BrowserType type, QString id);
+    void registerBrowserSendEvent(AceWebBrowser::BrowserType type, QString event_type, QString id);
+
+    void handleBrowserVisiability(AceWebBrowser::BrowserType type, bool isVisible);
+    void handleParentCommandToShow(AceWebBrowser::BrowserType type);
+    void handleBrowserPosition(AceWebBrowser::BrowserType, const QPoint&, const QSize&);
+    void handleExitFullscreen();
+
+    void handleJSOPlay();
+    void handleJSOPause();
+    void handleJSOStop();
+    void handleJSOLinkOpenLater(QString, bool, bool, QString);
+    void handleJSOSetFullscreen(bool);
+    void handleJSOToggleFullscreen();
+
+    void availableBrowserShowing(AceWebBrowser::BrowserType type, bool available);
+
+    void handleVoutChanged(bool);
+    void handleUserPauseAction();
+    void handleUserStopAction();
+    void handleInputState(int, bool);
+
+    //tmp
+    void registerIESuccess(AceWebBrowser::BrowserType type, QString id);
+    void registerIEError(AceWebBrowser::BrowserType type, QString id);
+
+    void deleteIEBrowser();
+
+signals:
+    void askUserData();
+    void askErrorDialog(QString, QString);
+    void askMiningDialog(int);
+    void setFullscreenVideo( bool );
+    void backgroundText( QString );
+
+    void notifyFullscreenChanged(bool);
+    void notifySizeChanged(const QSize&);
+    void enableFsControlsHiding(bool);
+    void placeFsControls(int, int);
+    void notifyPauseClicked();
+
+private:
+    BrowserHolder *browserPlaceholder;
+    AceWebBrowser::BrowserManager *browserManager;
+    AceWebBrowser::IEBrowser2 *ieBrowser;
+    QTimer *mIeDeleteTimer;
+    QString m_last_webstat_play_id;
+    bool m_request_pause_ad;
+    QString m_link_2_open_later;
+    bool m_link_2_open_aceweb;
+    QString m_link_2_open_args;
+    bool m_status_bar_visible_cached;
 };
 
 #endif
diff -ru vlc-2.1.2.orig/modules/gui/qt4/menus.cpp vlc-2.1.2/modules/gui/qt4/menus.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/menus.cpp	2013-12-05 18:39:06.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/menus.cpp	2014-01-17 14:53:13.510986384 +0200
@@ -354,6 +354,9 @@
         ":/type/file-asym", SLOT( simpleOpenDialog() ), "Ctrl+O" );
     addDPStaticEntry( menu, qtr( "&Open Multiple Files..." ),
         ":/type/file-asym", SLOT( openFileDialog() ), "Ctrl+Shift+O" );
+    QString menu_line = qtr( "Open %1 Content ID..." ).arg(P2P_PRODUCT_NAME);
+    addDPStaticEntry( menu, qtr( qtu(menu_line) ),
+	    ":/type/acestream", SLOT( openCidDialog() ), "Ctrl+T" );
     addDPStaticEntry( menu, qtr( I_OP_OPDIR ),
         ":/type/folder-grey", SLOT( PLOpenDir() ), "Ctrl+F" );
     addDPStaticEntry( menu, qtr( "Open &Disc..." ),
@@ -417,6 +420,10 @@
     addDPStaticEntry( menu, qtr( I_MENU_CODECINFO ) ,
         ":/menu/info", SLOT( mediaCodecDialog() ), "Ctrl+J" );
 
+    QString menu_line = qtr( "%1 Information" ).arg(P2P_PRODUCT_NAME);
+    addDPStaticEntry( menu, qtr( qtu( menu_line ) ) ,
+        ":/menu/info", SLOT( mediaP2PInfoDialog() ), "Ctrl+K" );
+
 #ifdef ENABLE_VLM
     addDPStaticEntry( menu, qtr( I_MENU_VLM ), "", SLOT( vlmDialog() ),
         "Ctrl+Shift+W" );
@@ -904,7 +911,7 @@
 #endif
     action->setData( ACTION_STATIC );
 
-    action = menu->addAction( qtr( I_MENU_GOTOTIME ), THEDP, SLOT( gotoTimeDialog() ), qtr( "Ctrl+T" ) );
+    action = menu->addAction( qtr( I_MENU_GOTOTIME ), THEDP, SLOT( gotoTimeDialog() ), qtr( "Ctrl+G" ) );
     action->setData( ACTION_ALWAYS_ENABLED );
 
     menu->addSeparator();
@@ -915,6 +922,9 @@
     QMenu *openmenu = new QMenu( qtr( "Open Media" ), menu );
     addDPStaticEntry( openmenu, qtr( I_OP_OPF ),
         ":/type/file-asym", SLOT( openFileDialog() ) );
+    QString menu_line = qtr("Open %1 Content ID...").arg(P2P_PRODUCT_NAME);
+    addDPStaticEntry( openmenu, qtr( qtu(menu_line) ),
+	    ":/type/acestream", SLOT( openCidDialog() ) );
     addDPStaticEntry( openmenu, qtr( I_OP_OPDIR ),
         ":/type/folder-grey", SLOT( PLOpenDir() ) );
     addDPStaticEntry( openmenu, qtr( "Open &Disc..." ),
diff -ru vlc-2.1.2.orig/modules/gui/qt4/Modules.am vlc-2.1.2/modules/gui/qt4/Modules.am
--- vlc-2.1.4.orig/modules/gui/qt4/Modules.am	2014-02-21 15:59:56.000000000 +0200
+++ vlc-2.1.4/modules/gui/qt4/Modules.am	2014-05-13 15:01:35.000000000 +0300
@@ -25,6 +25,22 @@
 		adapters/seekpoints.moc.cpp \
 		adapters/chromaprint.moc.cpp \
 		adapters/variables.moc.cpp \
+		acewebbrowser/browser.moc.cpp \
+		acewebbrowser/browsermanager.moc.cpp \
+		acewebbrowser/cookiejar.moc.cpp \
+		acewebbrowser/cookiemanager.moc.cpp \
+		acewebbrowser/dummy.moc.cpp \
+		acewebbrowser/fake.moc.cpp \
+		acewebbrowser/javascriptobject.moc.cpp \
+		acewebbrowser/loaditem.moc.cpp \
+		acewebbrowser/networkmanager.moc.cpp \
+		acewebbrowser/proxyreply.moc.cpp \
+		acewebbrowser/proxyreply2.moc.cpp \
+		acewebbrowser/webpage.moc.cpp \
+		acewebbrowser/webview.moc.cpp \
+		acewebbrowser/iebrowser2.moc.cpp \
+		acewebbrowser/iejsobject.moc.cpp \
+		acewebbrowser/iewebview.moc.cpp \
 		dialogs/playlist.moc.cpp \
 		dialogs/bookmarks.moc.cpp \
 		dialogs/mediainfo.moc.cpp \
@@ -47,6 +63,8 @@
 		dialogs/firstrun.moc.cpp \
 		dialogs/extensions.moc.cpp \
 		dialogs/fingerprintdialog.moc.cpp \
+		dialogs/userinfo.moc.cpp \
+		dialogs/mininginfo.moc.cpp \
 		components/extended_panels.moc.cpp \
 		components/info_panels.moc.cpp \
 		components/info_widgets.moc.cpp \
@@ -86,6 +104,7 @@
 		ui/open_disk.h \
 		ui/open_net.h \
 		ui/open_capture.h \
+		ui/open_content_id.h \
 		ui/open.h \
 		ui/vlm.h \
 		ui/podcast_configuration.h \
@@ -209,6 +228,7 @@
 	pixmaps/toolbar/volume-muted.png \
 	pixmaps/toolbar/volume-slider-inside.png \
 	pixmaps/toolbar/volume-slider-outside.png \
+	pixmaps/types/acestream.png \
 	pixmaps/types/capture-card_16px.png \
 	pixmaps/types/cdda_16px.png \
 	pixmaps/types/disc_16px.png \
@@ -237,7 +257,20 @@
 	pixmaps/update.png \
 	pixmaps/valid.png \
 	pixmaps/search_clear.png \
-	pixmaps/lock.png
+	pixmaps/lock.png \
+	pixmaps/save.png \
+	pixmaps/toolbar/live.png \
+	pixmaps/toolbar/live_live.png \
+	pixmaps/toolbar/live_nolive.png \
+	res/loader.html \
+	res/back.png \
+	res/back_h.png \
+	res/back_disabled.png \
+	res/next.png \
+	res/next_h.png \
+	res/next_disabled.png \
+	res/close.png \
+	res/close_h.png
 
 BUILT_SOURCES += $(nodist_SOURCES_qt4)
 
@@ -287,6 +320,22 @@
 		adapters/seekpoints.cpp \
 		adapters/chromaprint.cpp \
 		adapters/variables.cpp \
+		acewebbrowser/browser.cpp \
+		acewebbrowser/browsermanager.cpp \
+		acewebbrowser/cookiejar.cpp \
+		acewebbrowser/cookiemanager.cpp \
+		acewebbrowser/dummy.cpp \
+		acewebbrowser/fake.cpp \
+		acewebbrowser/javascriptobject.cpp \
+		acewebbrowser/loaditem.cpp \
+		acewebbrowser/networkmanager.cpp \
+		acewebbrowser/proxyreply.cpp \
+		acewebbrowser/proxyreply2.cpp \
+		acewebbrowser/webpage.cpp \
+		acewebbrowser/webview.cpp \
+		acewebbrowser/iebrowser2.cpp \
+		acewebbrowser/iejsobject.cpp \
+		acewebbrowser/iewebview.cpp \
 		dialogs/playlist.cpp \
 		dialogs/bookmarks.cpp \
 		dialogs/preferences.cpp \
@@ -310,6 +359,8 @@
 		dialogs/podcast_configuration.cpp \
 		dialogs/extensions.cpp \
 		dialogs/fingerprintdialog.cpp \
+		dialogs/userinfo.cpp \
+		dialogs/mininginfo.cpp \
 		components/extended_panels.cpp \
 		components/info_panels.cpp \
 		components/info_widgets.cpp \
@@ -365,6 +416,24 @@
 	adapters/seekpoints.hpp \
 	adapters/chromaprint.hpp \
 	adapters/variables.hpp \
+	acewebbrowser/defines.hpp \
+	acewebbrowser/browser.hpp \
+	acewebbrowser/browsermanager.hpp \
+	acewebbrowser/cookiejar.hpp \
+	acewebbrowser/cookiemanager.hpp \
+	acewebbrowser/dummy.hpp \
+	acewebbrowser/fake.hpp \
+	acewebbrowser/javascriptobject.hpp \
+	acewebbrowser/loaditem.hpp \
+	acewebbrowser/networkmanager.hpp \
+	acewebbrowser/proxyreply.hpp \
+	acewebbrowser/proxyreply2.hpp \
+	acewebbrowser/webpage.hpp \
+	acewebbrowser/webview.hpp \
+	acewebbrowser/iebrowser2.hpp \
+	acewebbrowser/iewebview.hpp \
+	acewebbrowser/iejsobject.hpp \
+	acewebbrowser/exceptions.hpp \
 	dialogs/playlist.hpp \
 	dialogs/bookmarks.hpp \
 	dialogs/mediainfo.hpp \
@@ -388,6 +457,8 @@
 	dialogs/podcast_configuration.hpp \
 	dialogs/extensions.hpp \
 	dialogs/fingerprintdialog.hpp \
+	dialogs/userinfo.hpp \
+	dialogs/mininginfo.hpp \
 	components/extended_panels.hpp \
 	components/info_panels.hpp \
 	components/info_widgets.hpp \
@@ -441,6 +512,7 @@
 	ui/open_disk.ui \
 	ui/open_net.ui \
 	ui/open_capture.ui \
+	ui/open_content_id.ui \
 	ui/open.ui \
 	ui/podcast_configuration.ui \
 	ui/profiles.ui \
diff -ru vlc-2.1.2.orig/modules/gui/qt4/qt4.cpp vlc-2.1.2/modules/gui/qt4/qt4.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/qt4.cpp	2013-09-12 18:18:33.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/qt4.cpp	2014-03-04 17:32:04.605898355 +0200
@@ -462,7 +462,7 @@
 #else
             QSettings::NativeFormat,
 #endif
-            QSettings::UserScope, "vlc", "vlc-qt-interface" );
+            QSettings::UserScope, P2P_CONFIG_DIR, "vlc-21x-qt-interface" );
 
     /* Icon setting, Mac uses icon from .icns */
 #ifndef Q_WS_MAC
@@ -472,6 +472,14 @@
         app.setWindowIcon( QIcon::fromTheme( "vlc", QIcon( ":/logo/vlc256.png" ) ) );
 #endif
 
+    /* setup debug log */
+    QSettings tmp(QSettings::IniFormat, QSettings::UserScope, QCoreApplication::organizationName(), QCoreApplication::applicationName());
+    QString dir = QFileInfo(tmp.fileName()).absolutePath();
+    Log::SetupLogFile(QDir::toNativeSeparators(dir + "\\" + P2P_CONFIG_DIR + "\\qt4.log"));
+    QString addsetfile = QDir::toNativeSeparators(dir + "\\" + P2P_CONFIG_DIR + "\\qtconf");
+    QSettings addsettings(addsetfile, QSettings::IniFormat);
+    Log::SetupLogLevel(addsettings.value("loglevel", 0).toInt());
+
     /* Initialize timers and the Dialog Provider */
     DialogsProvider::getInstance( p_intf );
 
@@ -704,3 +712,60 @@
     msg_Dbg (p_wnd, "releasing video...");
     p_mi->releaseVideo();
 }
+
+QString Log::logfile = "";
+Log::LogLevel Log::loglevel = Log::LL_CRITICAL;
+
+void Log::SetupLogFile(const QString &path)
+{
+    logfile = path;
+
+    if(QFile(logfile).exists() && QFile(logfile).size() > 10*1024*1024)
+        QFile(logfile).remove();
+
+    qInstallMsgHandler(LogHandler);
+}
+
+void Log::SetupLogLevel(int level)
+{
+    if(level < LL_CRITICAL)
+        loglevel = LL_CRITICAL;
+    else if(level > LL_MAX)
+        loglevel = LL_MAX;
+    else
+        loglevel = static_cast<LogLevel>(level);
+}
+
+int Log::GetLogLevel()
+{
+    return static_cast<int>(loglevel);
+}
+
+#define LOG_TIME QTime::currentTime().toString("hh:mm:ss.zzz")
+void Log::LogHandler(QtMsgType type, const char *msg)
+{
+    if( logfile.isEmpty() )
+        return;
+    if((type == QtWarningMsg && loglevel < Log::LL_WARNING)
+            || (type == QtDebugMsg && loglevel < Log::LL_DEBUG))
+        return;
+
+    QFile file(logfile);
+    file.open(QIODevice::Append | QIODevice::Text);
+    QTextStream stream(&file);
+    switch(type) {
+    case QtDebugMsg:
+        stream << LOG_TIME << " Debug: " << msg << "\n";
+        break;
+    case QtCriticalMsg:
+        stream << LOG_TIME << " Critical: " << msg << "\n";
+        break;
+    case QtWarningMsg:
+        stream << LOG_TIME << " Warning: " << msg << "\n";
+        break;
+    case QtFatalMsg:
+        stream << LOG_TIME <<  " Fatal: " << msg << "\n";
+        abort();
+    }
+    file.close();
+}
diff -ru vlc-2.1.2.orig/modules/gui/qt4/qt4.hpp vlc-2.1.2/modules/gui/qt4/qt4.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/qt4.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/qt4.hpp	2014-03-04 17:29:56.717895517 +0200
@@ -32,6 +32,7 @@
 #include <vlc_common.h>    /* VLC_COMMON_MEMBERS for vlc_interface.h */
 #include <vlc_interface.h> /* intf_thread_t */
 #include <vlc_playlist.h>  /* playlist_t */
+#include <p2p_object.h>
 
 #define QT_NO_CAST_TO_ASCII
 #include <QString>
@@ -47,6 +48,7 @@
     IMEventTypeOffset     = 100,
     PLEventTypeOffset     = 200,
     MsgEventTypeOffset    = 300,
+    OtherEventTypeOffset = 400,
 };
 
 enum{
@@ -84,6 +86,7 @@
 };
 
 #define THEPL pl_Get(p_intf)
+#define THEP2P p2p_Get(p_intf)
 #define QPL_LOCK playlist_Lock( THEPL );
 #define QPL_UNLOCK playlist_Unlock( THEPL );
 
@@ -138,6 +141,26 @@
     return res;
 }
 
+class Log {
+public:
+    enum LogLevel {
+        LL_CRITICAL = 0,
+        LL_WARNING,
+        LL_DEBUG,
+        LL_MAX
+    };
+
+public:
+    static void SetupLogFile(const QString &path);
+    static void SetupLogLevel(int level);
+    static int GetLogLevel();
+    static void LogHandler(QtMsgType type, const char *msg);
+
+private:
+    static QString logfile;
+    static LogLevel loglevel;
+};
+
 /* After this day of the year, the usual VLC cone is replaced by another cone
  * wearing a Father Xmas hat.
  * Note this icon doesn't represent an endorsment of Coca-Cola company.
diff -ru vlc-2.1.2.orig/modules/gui/qt4/ui/sprefs_interface.ui vlc-2.1.2/modules/gui/qt4/ui/sprefs_interface.ui
--- vlc-2.1.2.orig/modules/gui/qt4/ui/sprefs_interface.ui	2013-09-12 18:18:33.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/ui/sprefs_interface.ui	2014-01-17 13:42:05.000000000 +0200
@@ -410,6 +410,32 @@
      </layout>
     </widget>
    </item>
+   <item row="2" column="0" colspan="2">
+    <widget class="QGroupBox" name="browserPlugin">
+     <property name="title">
+      <string>Browser Plugin</string>
+     </property>
+     <layout class="QGridLayout" name="gridLayout_6" columnminimumwidth="0,0">
+      <item row="0" column="0">
+       <widget class="QCheckBox" name="pluginFSController">
+        <property name="text">
+         <string>Show controls in full screen mode</string>
+        </property>
+       </widget>
+      </item>
+      <item row="0" column="1">
+       <widget class="QCheckBox" name="playOnClick">
+        <property name="enabled">
+         <bool>true</bool>
+        </property>
+        <property name="text">
+         <string>Perform play/pause action on plugin's area single click</string>
+        </property>
+       </widget>
+      </item>
+     </layout>
+    </widget>
+   </item>
    <item>
     <widget class="QGroupBox" name="OneInterfaceBox">
      <property name="title">
diff -ru vlc-2.1.4.orig/modules/gui/qt4/util/input_slider.cpp vlc-2.1.4/modules/gui/qt4/util/input_slider.cpp
--- vlc-2.1.4.orig/modules/gui/qt4/util/input_slider.cpp	2014-02-14 19:40:50.000000000 +0200
+++ vlc-2.1.4/modules/gui/qt4/util/input_slider.cpp	2014-03-05 18:00:31.212232919 +0200
@@ -63,10 +63,21 @@
     chapters = NULL;
     mHandleLength = -1;
     b_seekable = true;
-    alternativeStyle = NULL;
+    //alternativeStyle = NULL;
+    
+    b_disableDragSeek = false;
+    b_isLive = false;
+    b_ignore_next_is_live_changing = false;
+    live_first = 0; 
+    live_last = 0;
+    pos = 0;
+    first_ts = 0;
+    last_ts = 0;
+    last = 0;
+    f_buffer_pos = .0;
 
     // prepare some static colors
-    QPalette p = palette();
+    /*QPalette p = palette();
     QColor background = p.color( QPalette::Active, QPalette::Window );
     tickpointForeground = p.color( QPalette::Active, QPalette::WindowText );
     tickpointForeground.setHsv( tickpointForeground.hue(),
@@ -93,7 +104,7 @@
         shadowBase = QColor( 60, 60, 60 ); // Palette's shadow is too bright
     shadowDark = shadowBase.darker( 150 );
     shadowLight = shadowBase.lighter( 180 );
-    shadowLight.setAlpha( 50 );
+    shadowLight.setAlpha( 50 );*/
 
     /* Timer used to fire intermediate updatePos() when sliding */
     seekLimitTimer = new QTimer( this );
@@ -113,11 +124,11 @@
 
     /* Use the new/classic style */
     setMinimumHeight( 18 );
-    if( !b_classic )
-    {
-        alternativeStyle = new SeekStyle;
-        setStyle( alternativeStyle );
-    }
+    //if( !b_classic )
+    //{
+    //    alternativeStyle = new SeekStyle;
+    //    setStyle( alternativeStyle );
+    //}
 
     /* Init to 0 */
     setPosition( -1.0, 0, 0 );
@@ -141,8 +152,8 @@
 SeekSlider::~SeekSlider()
 {
     delete chapters;
-    if ( alternativeStyle )
-        delete alternativeStyle;
+    //if ( alternativeStyle )
+    //    delete alternativeStyle;
 }
 
 /***
@@ -176,23 +187,93 @@
     else
         setEnabled( b_seekable );
 
-    if( !isSliding )
-        setValue( (int)( pos * 1000.0 ) );
+    if( !b_isLive ) {
+        if( !isSliding )
+            setValue( (int)( pos * 1000.0 ) );
+
+        inputLength = length;
+    }
+}
+
+void SeekSlider::isLiveStreamMode( bool is_live )
+{
+    if( !b_ignore_next_is_live_changing ) {
+        b_isLive = is_live;
+        if( !b_isLive ) {
+            setValue( 0 );
+            inputLength = 0;
+            f_buffer_pos = .0;
+        }
+    }
+    else
+        b_ignore_next_is_live_changing = false;
+}
 
-    inputLength = length;
+void SeekSlider::setLivePosition( int _live_first, int _live_last, int _pos, int _first_ts, int _last_ts, int _last, int _buffer_pieces )
+{
+    if( !b_isLive )
+        return;
+    live_first = _live_first; 
+    live_last = _live_last;
+    pos = _pos;
+    first_ts = _first_ts;
+    last_ts = _last_ts;
+    last = _last;
+    
+    inputLength = last_ts - first_ts;
+    
+    if( !isSliding ) {
+        int range = 0;
+        if( live_last > live_first )
+            range = live_last - live_first;
+        else
+            range = last - live_first + live_last;
+
+        int current = 0;
+        if( (live_first < pos) && (pos < last) )
+            current = pos - live_first;
+        else
+            current = last - live_first + pos;
+        double __pos = (double)current / (double)range;
+        
+        f_buffer_pos = ((float)(range - _buffer_pieces) / (float)range) * 1000.0;
+        
+        if( __pos>1.0 ) __pos = 1.0;
+        setValue( (int)(__pos * 1000.0 ) );
+    }
 }
 
 void SeekSlider::startSeekTimer()
 {
     /* Only fire one update, when sliding, every 150ms */
-    if( isSliding && !seekLimitTimer->isActive() )
+    if( !b_disableDragSeek && isSliding && !seekLimitTimer->isActive() )
         seekLimitTimer->start( 150 );
 }
 
 void SeekSlider::updatePos()
 {
-    float f_pos = (float)( value() ) / 1000.0;
-    emit sliderDragged( f_pos ); /* Send new position to VLC's core */
+    if( !b_isLive ) {
+        float f_pos = (float)( value() ) / 1000.0;
+        emit sliderDragged( f_pos ); /* Send new position to VLC's core */
+    }
+    else {
+        float pos = (float)( value() ) / 1000.0;
+        int range = 0;
+        int seekPos = 0;
+        if( live_last > live_first ) {
+            range = live_last - live_first;
+            seekPos = live_first + (int)(range * pos);
+        }
+        else {
+            range = last - live_first + live_last;
+            int delta = (int)(range * pos);
+            if( delta > last - live_first )
+                seekPos = delta - (last - live_first);
+            else
+                seekPos = live_first + delta;
+        }
+        emit liveSeek( seekPos );
+    }
 }
 
 void SeekSlider::updateBuffering( float f_buffering_ )
@@ -205,14 +286,14 @@
 {
     if ( !isSliding && !isJumping ) return;
     isSliding = false;
-    bool b_seekPending = seekLimitTimer->isActive();
+    //bool b_seekPending = seekLimitTimer->isActive();
     seekLimitTimer->stop(); /* We're not sliding anymore: only last seek on release */
     if ( isJumping )
     {
         isJumping = false;
         return;
     }
-    if( b_seekPending && isEnabled() )
+    if( /*b_seekPending &&*/ isEnabled() )
         updatePos();
 }
 
@@ -305,10 +386,17 @@
         int margin = handleLength() / 2;
         int posX = qMax( rect().left() + margin, qMin( rect().right() - margin, event->x() ) );
 
-        QString chapterLabel;
+        if( b_isLive ) {
+            secstotimestr( psz_length, ( (size().width() - posX) * inputLength) / size().width() );
+            QString tmp = "-";
+            tmp.append(psz_length);
+            mTimeTooltip->setText( tmp, "" );
+        }
+        else {
+            QString chapterLabel;
 
-        if ( orientation() == Qt::Horizontal ) /* TODO: vertical */
-        {
+            if ( orientation() == Qt::Horizontal ) /* TODO: vertical */
+            {
                 QList<SeekPoint> points = chapters->getPoints();
                 int i_selected = -1;
                 bool b_startsnonzero = false;
@@ -322,13 +410,18 @@
                 }
                 if ( i_selected >= 0 && i_selected < points.size() )
                     chapterLabel = points.at( i_selected ).name;
+            }
+
+            secstotimestr( psz_length, ( posX * inputLength ) / size().width() );
+            mTimeTooltip->setText( psz_length, chapterLabel );
         }
 
         QPoint target( event->globalX() - ( event->x() - posX ),
                   QWidget::mapToGlobal( QPoint( 0, 0 ) ).y() );
         if( likely( size().width() > handleLength() ) ) {
             secstotimestr( psz_length, ( ( posX - margin ) * inputLength ) / ( size().width() - handleLength() ) );
-            mTimeTooltip->setTip( target, psz_length, chapterLabel );
+            //mTimeTooltip->setTip( target, psz_length, chapterLabel );
+            mTimeTooltip->setPos( target ); // move( p )
         }
     }
     event->accept();
@@ -450,6 +543,230 @@
             || hideHandleTimer->isActive();
 }
 
+QSize SeekSlider::handleSize() const
+{
+    const int size = ( orientation() == Qt::Horizontal ? height() : width() );
+    return QSize( size, size );
+}
+
+void SeekSlider::paintEvent( QPaintEvent *event ) 
+{
+    if( b_classic )
+        return QSlider::paintEvent( event );
+
+    QStyleOptionSlider option;
+    initStyleOption( &option );
+
+    /* */
+    QPainter painter( this );
+    painter.setRenderHints( QPainter::Antialiasing );
+
+    // draw bar
+    const int barCorner = 3;
+    qreal sliderPos     = -1;
+    int range           = MAXIMUM;
+    QRect barRect       = rect();
+
+    // adjust positions based on the current orientation
+    if ( option.sliderPosition != 0 )
+    {
+        switch ( orientation() )
+        {
+            case Qt::Horizontal:
+                sliderPos = ( ( (qreal)width() ) / (qreal)range )
+                        * (qreal)option.sliderPosition;
+                break;
+            case Qt::Vertical:
+                sliderPos = ( ( (qreal)height() ) / (qreal)range )
+                        * (qreal)option.sliderPosition;
+                break;
+        }
+    }
+
+    switch ( orientation() )
+    {
+        case Qt::Horizontal:
+            barRect.setHeight( height() /2 );
+            break;
+        case Qt::Vertical:
+            barRect.setWidth( width() /2 );
+            break;
+    }
+
+    barRect.moveCenter( rect().center() );
+
+    // set the background color and gradient
+    QColor backgroundBase( palette().window().color() );
+    QLinearGradient backgroundGradient( 0, 0, 0, height() );
+    backgroundGradient.setColorAt( 0.0, backgroundBase.darker( 140 ) );
+    backgroundGradient.setColorAt( 1.0, backgroundBase );
+
+    // set the foreground color and gradient
+    QColor foregroundBase( 50, 156, 255 );
+    QLinearGradient foregroundGradient( 0, 0, 0, height() );
+    foregroundGradient.setColorAt( 0.0,  foregroundBase );
+    foregroundGradient.setColorAt( 1.0,  foregroundBase.darker( 140 ) );
+
+    // draw a slight 3d effect on the bottom
+    painter.setPen( QColor( 230, 230, 230 ) );
+    painter.setBrush( Qt::NoBrush );
+    painter.drawRoundedRect( barRect.adjusted( 0, 2, 0, 0 ), barCorner, barCorner );
+
+    // draw background
+    painter.setPen( Qt::NoPen );
+    painter.setBrush( backgroundGradient );
+    painter.drawRoundedRect( barRect, barCorner, barCorner );
+
+    // adjusted foreground rectangle
+    QRect valueRect = barRect.adjusted( 1, 1, -1, 0 );
+    
+    switch ( orientation() )
+    {
+        case Qt::Horizontal:
+            valueRect.setWidth( b_isLive ? width() - int( sliderPos ) : qMin( width(), int( sliderPos ) ) );
+            if( b_isLive )
+                valueRect.moveRight( rect().right() );
+            break;
+        case Qt::Vertical:
+            valueRect.setHeight( b_isLive ? height() - sliderPos : qMin( height(), int( sliderPos ) ) );
+            if( b_isLive )
+                valueRect.moveTop( rect().top() );
+            else
+                valueRect.moveBottom( rect().bottom() );
+            break;
+    }
+
+
+    if ( option.sliderPosition > minimum() && option.sliderPosition <= maximum() )
+    {
+        // draw foreground
+        if( b_isLive ) {
+            QColor liveColor = QColor( "Orange" );
+            painter.setBrush( liveColor );
+            painter.setPen( Qt::NoPen );
+            painter.drawRoundedRect( valueRect, barCorner, barCorner );
+        }
+        else {
+            painter.setPen( Qt::NoPen );
+            painter.setBrush( foregroundGradient );
+            painter.drawRoundedRect( valueRect, barCorner, barCorner );
+        }
+    }
+
+    if( b_isLive &&  f_buffer_pos != 0 ) {
+    
+        QRect bufferRect = barRect.adjusted( 1, 1, -1, 0 );
+        qreal bufferPos = -1;
+        switch ( orientation() )
+        {
+            case Qt::Horizontal:
+                bufferPos = qMax( sliderPos, ( (qreal)width() / (qreal)range ) * (qreal)f_buffer_pos );
+                bufferRect.setWidth( width() - int( bufferPos ) );
+                bufferRect.moveRight( rect().right() );
+                break;
+            case Qt::Vertical:
+                bufferPos = qMax( sliderPos, ( (qreal)height() / (qreal)range ) * (qreal)f_buffer_pos );
+                bufferRect.setHeight( height() - bufferPos );
+                bufferRect.moveTop( rect().top() );
+                break;
+        }
+        
+        painter.setPen( Qt::NoPen );
+        painter.setBrush( foregroundGradient );
+        painter.drawRoundedRect( bufferRect, barCorner, barCorner );
+    }
+    
+    // draw buffering overlay
+    if ( f_buffering < 1.0 )
+    {
+        QRect innerRect = barRect.adjusted( 1, 1,
+                            barRect.width() * ( -1.0 + f_buffering ) - 1, 0 );
+        QColor overlayColor = QColor( "Orange" );
+        overlayColor.setAlpha( 128 );
+        painter.setBrush( overlayColor );
+        painter.drawRoundedRect( innerRect, barCorner, barCorner );
+    }
+
+    if ( option.state & QStyle::State_MouseOver || isAnimationRunning() )
+    {
+        /* draw chapters tickpoints */
+        if ( chapters && inputLength && size().width() )
+        {
+            QColor background = palette().color( QPalette::Active, QPalette::Background );
+            QColor foreground = palette().color( QPalette::Active, QPalette::WindowText );
+            foreground.setHsv( foreground.hue(),
+                            ( background.saturation() + foreground.saturation() ) / 2,
+                            ( background.value() + foreground.value() ) / 2 );
+            if ( orientation() == Qt::Horizontal ) /* TODO: vertical */
+            {
+                QList<SeekPoint> points = chapters->getPoints();
+                foreach( SeekPoint point, points )
+                {
+                    int x = point.time / 1000000.0 / inputLength * size().width();
+                    painter.setPen( foreground );
+                    painter.setBrush( Qt::NoBrush );
+                    painter.drawLine( x, height(), x, height() - CHAPTERSSPOTSIZE );
+                }
+            }
+        }
+
+        // draw handle
+        if ( sliderPos != -1 )
+        {
+            const int margin = 0;
+            QSize hSize = handleSize() - QSize( 6, 6 );
+            QPoint pos;
+
+            switch ( orientation() )
+            {
+                case Qt::Horizontal:
+                    pos = QPoint( sliderPos - ( hSize.width() / 2 ), 2 );
+                    pos.rx() = qMax( margin, pos.x() );
+                    pos.rx() = qMin( width() - hSize.width() - margin, pos.x() );
+                    break;
+                case Qt::Vertical:
+                    pos = QPoint( 2, height() - ( sliderPos + ( hSize.height() / 2 ) ) );
+                    pos.ry() = qMax( margin, pos.y() );
+                    pos.ry() = qMin( height() - hSize.height() - margin, pos.y() );
+                    break;
+            }
+
+            QPalette p;
+            QPoint shadowPos( pos - QPoint( 2, 2 ) );
+            QSize sSize( handleSize() - QSize( 2, 2 ) );
+
+            // prepare the handle's gradient
+            QLinearGradient handleGradient( 0, 0, 0, hSize.height() );
+            handleGradient.setColorAt( 0.0, p.window().color().lighter( 120 ) );
+            handleGradient.setColorAt( 0.9, p.window().color().darker( 120 ) );
+
+            // prepare the handle's shadow gradient
+            QColor shadowBase = p.shadow().color();
+            if( shadowBase.lightness() > 100 )
+                shadowBase = QColor( 60, 60, 60 ); // Palette's shadow is too bright
+            QColor shadowDark( shadowBase.darker( 150 ) );
+            QColor shadowLight( shadowBase.lighter( 180 ) );
+            shadowLight.setAlpha( 50 );
+
+            QRadialGradient shadowGradient( shadowPos.x() + ( sSize.width() / 2 ),
+                                            shadowPos.y() + ( sSize.height() / 2 ),
+                                            qMax( sSize.width(), sSize.height() ) / 2 );
+            shadowGradient.setColorAt( 0.4, shadowDark );
+            shadowGradient.setColorAt( 1.0, shadowLight );
+
+            painter.setPen( Qt::NoPen );
+            painter.setOpacity( mHandleOpacity );
+
+            // draw the handle's shadow
+            painter.setBrush( shadowGradient );
+            painter.drawEllipse( shadowPos.x(), shadowPos.y() + 1, sSize.width(), sSize.height() );
+
+            // finally draw the handle
+            painter.setBrush( handleGradient );
+            painter.drawEllipse( pos.x(), pos.y(), hSize.width(), hSize.height() );
+        }
+    }
+}
 
 /* This work is derived from Amarok's work under GPLv2+
     - Mark Kretschmann
diff -ru vlc-2.1.2.orig/modules/gui/qt4/util/input_slider.hpp vlc-2.1.2/modules/gui/qt4/util/input_slider.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/util/input_slider.hpp	2013-06-24 21:00:38.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/util/input_slider.hpp	2014-01-17 16:45:15.870992269 +0200
@@ -67,8 +67,10 @@
     virtual void leaveEvent( QEvent * );
     virtual void hideEvent( QHideEvent * );
 
+    virtual void paintEvent( QPaintEvent* event );
     virtual bool eventFilter( QObject *obj, QEvent *event );
 
+    QSize handleSize() const;
     virtual QSize sizeHint() const;
 
     void processReleasedButton();
@@ -90,15 +92,26 @@
     bool b_seekable;
     int mHandleLength;
 
+    bool b_disableDragSeek;
+    bool b_isLive;
+    int live_first; 
+    int live_last;
+    int pos;
+    int first_ts;
+    int last_ts;
+    int last;
+    float f_buffer_pos;
+    bool b_ignore_next_is_live_changing;
+
     /* Colors & gradients */
-    QSize gradientsTargetSize;
+    /*QSize gradientsTargetSize;
     QLinearGradient backgroundGradient;
     QLinearGradient foregroundGradient;
     QLinearGradient handleGradient;
     QColor tickpointForeground;
     QColor shadowDark;
     QColor shadowLight;
-    QCommonStyle *alternativeStyle;
+    QCommonStyle *alternativeStyle;*/
 
     /* Handle's animation */
     qreal mHandleOpacity;
@@ -110,6 +123,11 @@
     void setSeekable( bool b ) { b_seekable = b ; }
     void updateBuffering( float );
     void hideHandle();
+    
+    void setLivePosition( int, int, int, int, int, int, int );
+    void disableDragSeek( bool val ) { b_disableDragSeek = val; }
+    void isLiveStreamMode( bool is_live );
+    void setIgnoreLiveStreamChanging() { b_ignore_next_is_live_changing = true; }
 
 private slots:
     void startSeekTimer();
@@ -117,7 +135,7 @@
 
 signals:
     void sliderDragged( float );
-
+    void liveSeek( int );
 
     friend class SeekStyle;
 };
diff -ru vlc-2.1.2.orig/modules/gui/qt4/util/timetooltip.cpp vlc-2.1.2/modules/gui/qt4/util/timetooltip.cpp
--- vlc-2.1.2.orig/modules/gui/qt4/util/timetooltip.cpp	2013-09-12 18:18:33.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/util/timetooltip.cpp	2014-01-17 16:42:50.414992203 +0200
@@ -130,6 +130,21 @@
     painter.end();
 }
 
+void TimeTooltip::setText( const QString& time, const QString& text )
+{
+    mInitialized = true;
+    mDisplayedText = time;
+    if ( !text.isEmpty() )
+        mDisplayedText.append( " - " ).append( text );
+
+    if ( time.length() != mTime.length() || mText != text )
+        buildPath();
+
+    mTime = time;
+    mText = text;
+    update();
+}
+
 void TimeTooltip::setTip( const QPoint& target, const QString& time, const QString& text )
 {
     mInitialized = true;
@@ -145,6 +160,18 @@
         adjustPosition();
     }
 
+    update();
+}
+
+void TimeTooltip::setPos( const QPoint& pos )
+{
+    mInitialized = true;
+    if( mTarget != pos )
+    {
+        mTarget = pos;
+        adjustPosition();
+    }
+
     update();
 }
 
diff -ru vlc-2.1.2.orig/modules/gui/qt4/util/timetooltip.hpp vlc-2.1.2/modules/gui/qt4/util/timetooltip.hpp
--- vlc-2.1.2.orig/modules/gui/qt4/util/timetooltip.hpp	2013-09-12 18:18:33.000000000 +0300
+++ vlc-2.1.2/modules/gui/qt4/util/timetooltip.hpp	2014-01-17 16:41:32.570992049 +0200
@@ -36,6 +36,8 @@
     Q_OBJECT
 public:
     explicit TimeTooltip( QWidget *parent = 0 );
+    void setText( const QString& time, const QString& text );
+    void setPos( const QPoint& pos );
     void setTip( const QPoint& pos, const QString& time, const QString& text );
     virtual void show();
 
diff -ru vlc-2.1.2.orig/modules/gui/qt4/vlc.qrc vlc-2.1.2/modules/gui/qt4/vlc.qrc
--- vlc-2.1.2.orig/modules/gui/qt4/vlc.qrc	2013-12-05 18:39:06.000000000 +0200
+++ vlc-2.1.2/modules/gui/qt4/vlc.qrc	2014-01-17 15:44:08.582989163 +0200
@@ -1,11 +1,11 @@
 <RCC>
     <qresource prefix="/logo">
-        <file alias="vlc256.png">../../../share/icons/256x256/vlc.png</file>
-        <file alias="vlc128.png">../../../share/icons/128x128/vlc.png</file>
-        <file alias="vlc16.png">../../../share/icons/16x16/vlc.png</file>
-        <file alias="vlc48.png">../../../share/icons/48x48/vlc.png</file>
-        <file alias="vlc128-xmas.png">../../../share/icons/128x128/vlc-xmas.png</file>
-        <file alias="vlc48-xmas.png">../../../share/icons/48x48/vlc-xmas.png</file>
+        <file alias="vlc256.png">../../../share/icons/256x256/acestreamplayer.png</file>
+        <file alias="vlc128.png">../../../share/icons/128x128/acestreamplayer.png</file>
+        <file alias="vlc16.png">../../../share/icons/16x16/acestreamplayer.png</file>
+        <file alias="vlc48.png">../../../share/icons/48x48/acestreamplayer.png</file>
+        <file alias="vlc128-xmas.png">../../../share/icons/128x128/acestreamplayer-xmas.png</file>
+        <file alias="vlc48-xmas.png">../../../share/icons/48x48/acestreamplayer-xmas.png</file>
     </qresource>
     <qresource prefix="/menu">
         <file alias="help">pixmaps/menus/help_16px.png</file>
@@ -67,6 +67,10 @@
         <file alias="space">pixmaps/space.png</file>
         <file alias="slower2">pixmaps/slower2.png</file>
         <file alias="faster2">pixmaps/faster2.png</file>
+        <file alias="save" >pixmaps/save.png</file>
+        <file alias="live" >pixmaps/toolbar/live.png</file>
+        <file alias="live-live" >pixmaps/toolbar/live_live.png</file>
+        <file alias="live-nolive" >pixmaps/toolbar/live_nolive.png</file>
     </qresource>
     <qresource prefix="/buttons/playlist">
         <file alias="playlist_add">pixmaps/playlist/add.png</file>
@@ -90,6 +94,7 @@
         <file alias="net">pixmaps/types/type_net.png</file>
         <file alias="node">pixmaps/types/type_node.png</file>
         <file alias="playlist">pixmaps/types/type_playlist.png</file>
+        <file alias="acestream" >pixmaps/types/acestream.png</file>
     </qresource>
     <qresource prefix="/">
         <file alias="down_arrow">pixmaps/arrow_down_dark.png</file>
@@ -102,6 +107,17 @@
         <file alias="search_clear">pixmaps/search_clear.png</file>
         <file alias="dropzone">pixmaps/playlist/dropzone.png</file>
         <file alias="valid">pixmaps/valid.png</file>
+        <file alias="loader" >res/loader.html</file>
+    </qresource>
+    <qresource prefix="/images">
+        <file alias="back">res/back.png</file>
+        <file alias="back_h">res/back_h.png</file>
+        <file alias="back_d">res/back_disabled.png</file>
+        <file alias="next">res/next.png</file>
+        <file alias="next_h">res/next_h.png</file>
+        <file alias="next_d">res/next_disabled.png</file>
+        <file alias="close">res/close.png</file>
+        <file alias="close_h">res/close_h.png</file>
     </qresource>
     <qresource prefix="/prefsmenu">
         <file alias="cone_audio_64">pixmaps/prefs/spref_cone_Audio_64.png</file>
